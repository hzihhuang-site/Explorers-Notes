[{"id":0,"title":"","content":"","routePath":"/Explorers-Notes/about","lang":"","toc":[],"domain":"","frontmatter":{"layout":"page"},"version":""},{"id":1,"title":"CSS3 counter 计数器","content":"","routePath":"/Explorers-Notes/frontEnd/css/clip-path","lang":"","toc":[],"domain":"","frontmatter":{"title":"CSS3 counter 计数器","date":"2023-08-17T10:28:00.000Z"},"version":""},{"id":2,"title":"container 容器查询","content":"","routePath":"/Explorers-Notes/frontEnd/css/container","lang":"","toc":[],"domain":"","frontmatter":{"title":"container 容器查询","date":"2023-08-18T10:18:00.000Z"},"version":""},{"id":3,"title":"CSS3 counter 计数器","content":"#\n\nCSS计数器（counter）属性允许我们自动对页面上的元素进行编号，这在创建有序列表或章节标题时非常有用。\n\n\n什么是CSS计数器？#\n\nCSS计数器是一组用于自动递增编号的数据，它们可以通过CSS规则来增加、重置或显示。\n\n\n如何使用CSS计数器？#\n\n使用CSS计数器通常涉及以下步骤：\n\n 1. 定义一个计数器\n 2. 使用 counter-increment 属性递增计数器\n 3. 使用 content 属性和 counter() 或 counters() 函数来显示计数器的值\n\n下面我们将创建一个包含主列表项和子列表项的有序列表，并使用CSS计数器为它们自动编号。\n\n\n定义CSS样式#\n\n首先，我们定义CSS样式。\n\n\n\n\n创建HTML结构#\n\n接下来，我们创建列表的HTML结构。\n\n\n\n\n试一试#\n\n试试看，自己动手探索一下吧","routePath":"/Explorers-Notes/frontEnd/css/counter","lang":"","toc":[{"text":"什么是CSS计数器？","id":"什么是css计数器","depth":2,"charIndex":59},{"text":"如何使用CSS计数器？","id":"如何使用css计数器","depth":2,"charIndex":117},{"text":"定义CSS样式","id":"定义css样式","depth":3,"charIndex":295},{"text":"创建HTML结构","id":"创建html结构","depth":3,"charIndex":323},{"text":"试一试","id":"试一试","depth":2,"charIndex":357}],"domain":"","frontmatter":{"title":"CSS3 counter 计数器","date":"2023-08-17T10:28:00.000Z"},"version":""},{"id":4,"title":"CSS 邪门左道","content":"#\n\n\naaa222#\n\n\nbbb333#","routePath":"/Explorers-Notes/frontEnd/css/evil","lang":"","toc":[{"text":"aaa222","id":"aaa222","depth":3,"charIndex":3},{"text":"bbb333","id":"bbb333","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"CSS 邪门左道","date":"2024-10-28T12:00:00.000Z"},"version":""},{"id":5,"title":"Masonry 瀑布流","content":"#\n\n> 大概是今年 23 年 5 月份左右，在遇到的一个实现 Masonry 的问题，现在过了段时间在这里再讨论一下实现方案以及一些优缺点。\n\n\n介绍#\n\n> 瀑布流是一种很受图片网站欢迎的布局方式，英文名: Masonry Layout\n> \n> 特点: 内容由不同高度的方格从左到右自上而下依次排列组成。有种参差不齐又缺又很整齐的感觉。 以下站点皆是瀑布流布局的例子\n\n * Pexels\n * 花瓣网\n * Pinterset\n * Civitai\n\n\nJS 实现#\n\n> 自己写或是加载其他人已经写好的库。目前这种方式是最容易也最完美的方案\n\n原理基本上都是通过 JavaScript 计算共有多少个卡片，再计算每个卡片的宽度和高度，因父容器的宽度每行放置多少个卡片等等要求。将全部卡片的\nposition 都设置成 absolute 逐一计算去 top 和 left 定位。\n\n由于所有卡片位置都是计算出来的，所以还能在父容器宽度改变的时候，将卡片动态移动并且重新排列。\n\n唯一的不足是因为介入了太多的计算，卡片多的时候不建议根据父元素宽度动态重新排列，否则可能会出现卡顿现象。并且由于计算需要时间完成，在完成之前卡片并未设置位置，所\n以基本上都堆叠在左上角了\n\n * 原生: Masonry.js、Isotope.js\n\n * React：react-responsive-masonry、react-masonry-component\n\n * Vue: vue-waterfall、vue-waterfall-easy、vue-virtual-collection、vue-grid-layout\n\n\nCSS 实现#\n\n> CSS 直接支持，性能优秀。\n\n\n多列布局#\n\n\n\n> 只需要两行代码就能实现。但是它有一个缺陷，就是只能从上到下，再从左到右排列。\n> \n> 如果我们想列出的内容是根据时间由新至旧排列，这样的排列顺序就未必合适了。我们辉期望它是由左到右，再由上到下排列。\n\n案例一\n\n\nFlex 布局#\n\n> 利用 flex 竖着排列，固定容器高度让它自动换行实现，如果想要完美展示需要我们计算最合适的容器高度。\n> \n> 缺陷同上\n> \n> 但是由于 flex 中有一个 order 的属性，可以让我们自己控制图片的排列顺序，所以可控性会高一点，甚至经过计算后也能实现 从左到右，从上至下的排列\n\n\n\n案例二\n\n\nGrid 布局新特性（实验阶段）#\n\n> grid-template-rows: masonry; 可在 火狐浏览器（开启实验模式） 中试用\n\n\n\n\n结尾#\n\n> 最后可以看出，Masonry 完美的解决方法还未出现，都有各自的优劣势，不过现在用 js 会比较方便功能性会强。 很多使用 js 实现 Masonry\n> 网站都基本上限制了他的动态设置列数，或者延迟计算（等待容器宽度变化停止后）。主要是当卡片变多的时候动态计算会大幅度影响性能，所以限制列数或者延迟计算是必要的\n> 。\n\n * 花瓣网 没有限制，在浏览器大小变化时会卡顿是一个很好的例子。\n * Pexels 则是限制了它的变化。\n * Civitai 进行了延迟计算，等待容器宽度停止变化后再计算变化。","routePath":"/Explorers-Notes/frontEnd/css/masonry","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":73},{"text":"JS 实现","id":"js-实现","depth":2,"charIndex":230},{"text":"CSS 实现","id":"css-实现","depth":2,"charIndex":708},{"text":"多列布局","id":"多列布局","depth":3,"charIndex":736},{"text":"Flex 布局","id":"flex-布局","depth":3,"charIndex":855},{"text":"Grid 布局新特性（实验阶段）","id":"grid-布局新特性实验阶段","depth":3,"charIndex":1020},{"text":"结尾","id":"结尾","depth":2,"charIndex":1095}],"domain":"","frontmatter":{"title":"Masonry 瀑布流","date":"2023-08-18T10:18:00.000Z"},"version":""},{"id":6,"title":"SVG 深入浅出","content":"#\n\n\n一、SVG 简介#\n\n> Scalable Vector Graphics —— 可缩放的矢量图\n> \n> SVG 是 W3C 推出的基于 XML 的二维矢量图形标准，也就是一种用于描述二维的矢量图形。SVG 可以提供高质量的矢量图形渲染，同时由于支持\n> JavaScript 和文档对象模型，SVG 图形通常具有强大的交互能力。\n\n\n1、SVG 的优势#\n\n * SVG 是可伸缩的，并且伸缩不会对图像质量造成影响，而一般普通的图像放大或者缩小容易导致变形，例如 JPG 或 PNG 等。\n * SVG 图像可在任何的分辨率下被高质量地打印。\n * SVG 图像可被多种工具读取和修改，例如文本编辑器等。\n * SVG 图像可被搜索、索引、脚本化或压缩 。\n * SVG 图像与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。\n * SVG 可以与 Java 技术一起运行。\n\n\n2、SVG 的使用方式#\n\n * 直接在 HTML 中作为 标签使用。\n * 在 HTML 中通过 标签来引用。\n * 通过浏览器直接打开 SVG 文件。\n * 可以作为 CSS 背景使用。\n\n\n二、学习如何编写 SVG#\n\n\n1、所有的图形都要求写在 svg 中。#\n\n\n2、基本图形、属性、API#\n\n> 基本图形 —— 、、、、、\n\nrect —— 矩形\n\n\n\ncircle —— 圆\n\n\n\nellipse —— 椭圆\n\n\n\nline —— 线\n\n\n\npolyline —— 折线\n\n\n\npolygon —— 多边形\n\n\n\n> 基本属性 —— fill、stroke、stroke-width、transform\n\n * fill —— 填充颜色\n * stroke —— 描边颜色\n * stroke-width —— 描边厚度\n * transform —— 类似于 CSS3 的 transform\n\n> 基本操作 API\n\n\n\n\n3、分组标签#\n\n * 标签来创建\n * 分组标签上的属性会被子标签继承\n * 使用 transform 属性定义分组坐标的变化\n * 分组标签可以嵌套\n\n\n\n\n4、颜色、渐变和笔刷#\n\nⅠ、认识 RGB 和 HSL#\n\n> RGB —— 不符合人类描述颜色的习惯\n\n * 红色、绿色、蓝色三个分量\n\n * 格式：rgb( r, g, b ) 或 #rrggbb\n\n * 每个分量取值范围：[ 0, 255 ]\n\n * 优势：显示器容易解析\n\n> HSL —— 符合人类描述颜色的习惯\n\n * 颜色、饱和度、亮度三个分量\n * 格式：hsl( h, s%, l%)\n * 取值范围：\n   * h: [ 0, 359 ]\n   * s，l: [0, 100 ]\n\nⅡ、渐变#\n\n> 线性渐变\n\n先看代码 —— 其实很容易懂~\n\n\n\n—— 相当于一个容器，里面存放的就是像渐变一样的工具标签\n\n—— 线性渐变标签\n\n\n\n—— 渐变的颜色切换\n\n\n\n> 径向渐变\n\n\n\n> 笔刷 —— 自定义背景\n\n\n\n使用此标签定义好一个背景，可以被其他图形以 fill 的形式调用，成为那个图形的背景\n\n\n三、Path 的使用 （高级）#\n\n\n1、Path 概述#\n\n> 一个强大的绘图工具\n> \n> 规范： http://www.w3.org/TR/SVG11/paths.html\n> \n> 由命令及其参数组成的字符串\n\n命令基本规律\n\n * 区分大小写：大写表示坐标参数为绝对位置，小写则为相对位置\n * 最后的参数表示最终要到达的位置\n * 上一个命令结束的位置就是下一个命令开始的位置\n * 命令可以重复表示重复执行同一条命令\n\n\n2、移动和直线命令#\n\n * M (x, y)+ 移动画笔，后面如果由重复参数，会当作是 L 命令处理\n * L (x, y)+ 绘制直线到指定位置\n * H (x)+ 绘制水平线到指定的 x 位置\n * V (y)+ 绘制竖直线到指定的 y 位置\n * m、l、h、v 使用相对位置绘制\n\n\n\n\n3、弧线命令#\n\n> A ( rx, ry xr, laf, sf, x, y ) —— 绘制弧线\n\n * rx - ( radius-x ) 弧线所在椭圆的 x 半轴长\n * ry - ( radius-y ) 弧线所在椭圆的 y 半轴长\n * xr - ( xAxis-rotation ) 弧线所在椭圆的长轴角度\n * laf - ( large-arc-flag ) 是否选择弧长较长的那一段弧\n * sf - ( sweep-flag ) 是否选择逆时针方向的那一段弧\n * x，y - 弧的终点位置\n\n\n\n\n4、贝塞尔曲线命令#\n\nQ(x1 y1 x y) —— 二次贝塞尔曲线\n\nC(x1 y1 x2 y2 x y) —— 三次贝塞尔曲线\n\n\n\n\n四、SVG 文本#\n\n\n1、text 和 tspan 创建文本#\n\n\n\n * 使用方法\n\n\n\n\n3、a - 插入超链接#\n\n> 使用方式与 html 中的 a 标签基本一致\n\n * 可以添加在任何的图形上\n * xlink:href 指定连接地址\n * xlink:title 指定连接提示\n * target 指定打开目标\n\n\n五、图形的引用、裁切和蒙蔽#\n\n\n1、clip - 裁切图像#\n\n> clipPath 定义裁切路径 —— 路径为两个图形的重合处\n\n\n\n> 图形上加 clip-path 属性指定此块区域被显示出来，其余部分被裁减\n\n\n\n\n2、mask - 创建蒙板#\n\n> mask 标签定义蒙板\n\n\n\n> 图形添加 mask 属性绑定蒙板\n\n\n\n\n六、SVG 动画#\n\n> svg动画有两种方式绑定要进行动画的元素\n> \n> xlink:href=\"url(#id)\"\n> \n> 直接写在 元素标签里\n\n\n1、animate#\n\n\n\n\n2、animateTransform#\n\n> 用法与上面一致，是对 transform 属性的动画修改\n\n\n3、animateMotion#\n\n","routePath":"/Explorers-Notes/frontEnd/html/svg","lang":"","toc":[{"text":"一、SVG 简介","id":"一svg-简介","depth":2,"charIndex":3},{"text":"1、SVG 的优势","id":"1svg-的优势","depth":3,"charIndex":172},{"text":"2、SVG  的使用方式","id":"2svg--的使用方式","depth":3,"charIndex":-1},{"text":"二、学习如何编写 SVG","id":"二学习如何编写-svg","depth":2,"charIndex":500},{"text":"1、所有的图形都要求写在 svg 中。","id":"1所有的图形都要求写在-svg-中","depth":3,"charIndex":516},{"text":"2、基本图形、属性、API","id":"2基本图形属性api","depth":3,"charIndex":539},{"text":"3、分组标签","id":"3分组标签","depth":3,"charIndex":824},{"text":"4、颜色、渐变和笔刷","id":"4颜色渐变和笔刷","depth":3,"charIndex":905},{"text":"Ⅰ、认识 RGB 和 HSL","id":"ⅰ认识-rgb-和-hsl","depth":4,"charIndex":918},{"text":"Ⅱ、渐变","id":"ⅱ渐变","depth":4,"charIndex":1156},{"text":"三、Path 的使用 （高级）","id":"三path-的使用-高级","depth":2,"charIndex":1319},{"text":"1、Path 概述","id":"1path-概述","depth":3,"charIndex":1338},{"text":"2、移动和直线命令","id":"2移动和直线命令","depth":3,"charIndex":1537},{"text":"3、弧线命令","id":"3弧线命令","depth":3,"charIndex":1686},{"text":"4、贝塞尔曲线命令","id":"4贝塞尔曲线命令","depth":3,"charIndex":1946},{"text":"四、SVG 文本","id":"四svg-文本","depth":2,"charIndex":2017},{"text":"1、text 和  tspan  创建文本","id":"1text-和--tspan--创建文本","depth":3,"charIndex":-1},{"text":"3、a - 插入超链接","id":"3a---插入超链接","depth":3,"charIndex":2065},{"text":"五、图形的引用、裁切和蒙蔽","id":"五图形的引用裁切和蒙蔽","depth":2,"charIndex":2182},{"text":"1、clip - 裁切图像","id":"1clip---裁切图像","depth":3,"charIndex":2199},{"text":"2、mask - 创建蒙板","id":"2mask---创建蒙板","depth":3,"charIndex":2294},{"text":"六、SVG 动画","id":"六svg-动画","depth":2,"charIndex":2350},{"text":"1、animate","id":"1animate","depth":3,"charIndex":2429},{"text":"2、animateTransform","id":"2animatetransform","depth":3,"charIndex":2444},{"text":"3、animateMotion","id":"3animatemotion","depth":3,"charIndex":2498}],"domain":"","frontmatter":{"title":"SVG 深入浅出","date":"2022-12-07T18:57:32.000Z"},"version":""},{"id":7,"title":"IndexedDB 数据库","content":"#\n\n\n简介#\n\n\n背景#\n\n随着浏览器的处理能力不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少用户等待从服务器获取数据的时间。\n\n现有的浏览器端数据储存方案，都不适合储存大量数据。\n\n * cookie 不超过 4KB，且每次请求都会发送回服务器端\n * Window.name 属性缺乏安全性，且没有统一的标准\n * localStorage/sessionStorage 在 2.5MB 到 10MB 之间（各家浏览器不同）\n\n所以，需要一种新的解决方案，这就是IndexedDB诞生的背景。\n\n\n特点:#\n\n简单的说 IndexedDB 就是浏览器端数据库。它可以被网页脚本程序创建和操作。允许储存大量数据，提供查找接口，还能建立索引。 这些都是\nlocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\n\n 1. 键值对储存:\n\n> IndexedDB内部采用对象仓库（object\n> store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。在对象仓库中，数据以“键值对”的形式保存，每一个数据都有对应的键名，键名是\n> 独一无二的，不能有重复，否则会抛出一个错误。\n\n 2. 异步:\n\n> IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与localStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写\n> ，拖慢网页的表现。\n\n 3. 支持事务:\n\n> IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回到事务发生之前的状态，不存在只改\n> 写一部分数据的情况。\n\n 4. 同源策略:\n\n> IndexedDB也受到同源策略，每一个数据库对应创建该数据库的域名。来自不同域名的网页，只能访问自身域名下的数据库，而不能访问其他域名下的数据库。\n\n 5. 储存空间大:\n\n> IndexedDB的储存空间比localStorage大得多，一般来说不少于250MB。IE的储存上限是250MB，Chrome和Opera是剩余空间的某个\n> 百分比，Firefox则没有上限。\n\n 6. 支持二进制储存:\n\n> IndexedDB不仅可以储存字符串，还可以储存二进制数据。\n\n\n基本流程#\n\n\n前置#\n\n> 你需要知道:\n> \n>  1. 你可以在同一站点上创建多个 indexedDB(数据库)\n>  2. 每个数据下面也可以创建多个 objectStore(表)\n>  3. 每个表里面的数据是 key value 键值对的形式，且value值可以是：字符串、布尔、数组、对象、二进制等类型\n>  4. 异步！！！操作基本都是异步，需要繁琐的监听事件\n\n\n连接数据库#\n\n想要在 indexedDB 里面存储数据，需要两个步骤:\n\n 1. 连接(打开)数据库\n 2. 选择需要对哪个表 objectStore(表) 进行数据操作\n\n\n\n上面代码表示，打开一个名为 mydb、版本为 1 的数据库。如果该数据库不存在，则会新建该数据库。如果省略第二个参数，则会自动创建版本为1的该数据库。 open\n方法有两个参数:\n\n 1. name: 数据库名称(string)\n 2. version: 版本，是一个大于0的正整数（0将报错）\n\n打开数据库的结果是有可能触发 4 种事件\n\n * success: 打开成功\n * error: 打开失败\n * upgradeneeded: 第一次打开该数据库 or 数据库 版本 发生变化\n * blocked: 上一次的数据库连接还未关闭\n\n第一次打开数据库会先触发 upgradeneeded 再触发 success 事件。(每次版本升级同) ps: 版本只能升不能降\n\n\n\n * open 方法返回的是一个对象（IDBOpenDBRequest），回调函数定义在这个对象上面。\n * 回调函数接受一个事件对象 event 作为参数，它的 target.result 属性就指向打开的IndexedDB数据库。\n\n\n创建数据表#\n\n获取到数据库实例后，就能通过实例对象操作数据表了\n\n\n\n上面代码创建了一个名为 firstTable 的对象仓库。\n\n此方法还可以接受第二个对象参数，用来设置 表 的属性\n\n\n\n如果该对象仓库已经存在，就会抛出一个错误。可以通过 objectStoreNames 属性来检测错误。 objectStoreNames\n属性返回了当前数据库所有 表 的名称。可以使用 contains 方法，检查数据库是否包含某个 表\n\n\n\n\n数据库事务#\n\n> 因为数据库的特性，防止我们在改变数据的过程中突然中断了，会自动直接取消本次修改。 所以每次操作数据之前都必须创建数据库事务。\n\n\n\n此方法接收两个参数：\n\n 1. 数组：填写需要操作的表的名字（[table1, table2, ...]）\n 2. 操作类型：readonly(只读) or readwrite(读写)\n\n> 返回一个事务对象，该对象的 objectStore 方法用于获取指定的表(只能在你创建事物时传入的数组中选取)。\n\n\n\n返回的事务对象中有 3 个事件\n\n * abort: 事务中断\n * complete: 事务完成\n * error: 事务出错\n\n\n\n返回的 objectStore 对象有以下方法，用于操作数据。\n\n 1. add — 添加数据\n\n> add 方法是异步的，有自己的 success and error 事件\n\n\n\n 2. get — 读取数据\n\n> get 方法是异步的，有自己的 success and error 事件\n\n\n\n> 从创建事务到读取数据，所有操作方法也可以写成下面这样链式形式。\n\n\n\n 3. put — 更新数据\n\n> 用法同 add 相似，异步\n\n\n\n 4. delete — 删除数据\n\n> 用法同 get 相似, 异步\n\n\n\n到此为止，整个数据库的创建以及基本使用已经会了。 你可以自行尝试去创建或使用一下。\n\n\n高级用法#\n\n\nIndex#\n\n要根据其他对象字段进行搜索，我们需要创建一个名为“索引（index）”的附加数据结构。\n\n> objectStore.createIndex(name, keyPath, [options]);\n\n * name — 索引名称\n * keyPath — 索引应该跟踪的对象字段的路径（我们将根据该字段进行搜索）。\n * option：\n   * unique — 如果为true，则存储中只有一个对象在 keyPath 上具有给定值。\n   * multiEntry — 只有 keypath 上的值是数组时才使用。\n\n在这之前的实例中，我们是通过默认创建表的时候给的 keyPath 来查询的 假设我们想通过 age 年龄来进行搜索\n\n\n\n * 该索引将跟踪 age 字段。\n * 年龄不是唯一的，可能有很多人年龄相同，所以我们不设置唯一 unique 选项。\n * 年龄不是一个数组，因此不适用多入口 multiEntry 标志。\n\n基于 index 获取数据#\n\n\n\n基于 index 删除数据#\n\n\n\n\n光标(Cursors)#\n\n\nAPI 总览#\n\n\nIDBDatabase#\n\n * name — 数据库名称\n * objectStoreNames — 当前数据库下所有 表的名称 string[]\n * version — 当前数据库的版本\n * close() — 关闭当前数据库连接\n * createObjectStore() —— 创建表\n\n> (name: string, options?: { keyPath?: string; autoIncrement?: boolean; }) =>\n> IDBObjectStore\n\n * deleteObjectStore() — 删除表\n\n> (name: string) => void\n\n * transaction()\n * close\n * versionchange\n\n\nIDBTransaction#\n\n * db — 当前事务的数据库对象(IDBDatabase)\n * durability\n * error — 错误事务类型\n * mode — 事务的操作模式 readonly or readwrite\n * objectStoreNames — 当前事务下操作的表的名称 string[]\n * abort()\n * commit()\n * objectStore()\n * abort\n * complete\n * error\n\n\nIDBObjectStore#\n\n * autoIncrement — 是否 自增\n * indexNames — indexes 名称列表\n * keyPath — 当前 objectStore 索引\n * name\n * transaction\n * add() — 添加数据\n\n> (obj: any, key?: any) => IDBRequest\n\n * clear() — 清除全部数据\n\n> () => IDBRequest\n\n * count()\n * createIndex() — 创建 index\n\n> (name: string, keyPath: string, options?: { unique?: boolean; multiEntry?:\n> boolean; }) => IDBIndex\n\n * delete() — 删除数据\n\n> (key: any) => IDBRequest\n\n * deleteIndex() — 删除 index\n\n> (indexName: string) => void\n\n * get() — 查询数据\n\n> (key: any) => IDBRequest\n\n * getAll() — 查询全部数据\n\n> () => IDBRequest\n\n * put() — 更新数据\n\n> put(obj: any, key?: any) => IDBRequest\n\n * getAllKeys()\n * getKey()\n * index()\n * openCursor()\n * openKeyCursor()\n\n\nIDBRequest#\n\n * error — 请求失败\n * readyState — 请求状态\n * result — 请求结果\n * source — 请求来源\n * transaction — 请求到事务\n\n可监听事件:\n\n * error — 请求失败\n * success — 请求成功\n\n\nIDBIndex#\n\n * keyPath — 当前 index 索引\n * multiEntry\n * name — 当前 index 的 name\n * objectStore — 当前 index 的 objectStore\n * unique — 当前索引是否唯一\n * count()\n * get() — 返回以当前 index索引为 keyPath 的值\n\n> (key?: any) => IDBRequest\n\n * getAll()\n * getAllKeys()\n * getKey()\n * openCursor()\n * openKeyCursor()\n\n\nIDBCursor#\n\n * direction\n\n * key\n\n * primaryKey\n\n * request\n\n * source\n\n * advance()\n\n * continue()\n\n * continuePrimaryKey()\n\n * delete()\n\n * update()\n\n\nDexie.js#\n\n> 对 indexedDB 封装的一个库，能够让我们向 jquery 一样链式调用，省去了维护各种异步事件操作的时间。支持\n> TypeScript、React、Angular、Svelte\n> \n> 以 React 为例操作一遍\n\n\n创建#\n\n> 这里创建了一个名叫 mydb 的数据库，版本为 1，里面有一个表 fristTable，表内容规定为一个有 id，name，age 三个属性的对象，且 id\n> 自增\n\n\n\n> 如果使用的是 typescript 需要类型支持可以这样写\n\n\n\n\n添加数据#\n\n> 因为上面定义表的时候使用的是自增的 id 所以你可以不需要传入 id，按照整数自增下去，该与表中 key 一一对应 也可以传递\n> id，会做对比，如果当前表中没有该 id,那么添加成功，否则添加失败\n\n\n\n\n查询数据#\n\n> 查询 id 为 key 的数据\n\n\n\n\n筛选数据#\n\n> 筛选出 10 <= id < 20 区间的所有数据\n\n\n\n更多使用自行查看官网","routePath":"/Explorers-Notes/frontEnd/javascript/IndexedDB","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"背景","id":"背景","depth":3,"charIndex":9},{"text":"特点:","id":"特点","depth":3,"charIndex":263},{"text":"基本流程","id":"基本流程","depth":2,"charIndex":1024},{"text":"前置","id":"前置","depth":3,"charIndex":1032},{"text":"连接数据库","id":"连接数据库","depth":3,"charIndex":1215},{"text":"创建数据表","id":"创建数据表","depth":3,"charIndex":1766},{"text":"数据库事务","id":"数据库事务","depth":3,"charIndex":1986},{"text":"高级用法","id":"高级用法","depth":2,"charIndex":2590},{"text":"Index","id":"index","depth":3,"charIndex":2598},{"text":"基于 index 获取数据","id":"基于-index-获取数据","depth":4,"charIndex":3025},{"text":"基于 index 删除数据","id":"基于-index-删除数据","depth":4,"charIndex":3043},{"text":"光标(Cursors)","id":"光标cursors","depth":3,"charIndex":3062},{"text":"API 总览","id":"api-总览","depth":2,"charIndex":3077},{"text":"IDBDatabase","id":"idbdatabase","depth":3,"charIndex":3087},{"text":"IDBTransaction","id":"idbtransaction","depth":3,"charIndex":3435},{"text":"IDBObjectStore","id":"idbobjectstore","depth":3,"charIndex":3672},{"text":"IDBRequest","id":"idbrequest","depth":3,"charIndex":4368},{"text":"IDBIndex","id":"idbindex","depth":3,"charIndex":4520},{"text":"IDBCursor","id":"idbcursor","depth":3,"charIndex":4812},{"text":"Dexie.js","id":"dexiejs","depth":2,"charIndex":4965},{"text":"创建","id":"创建","depth":3,"charIndex":5094},{"text":"添加数据","id":"添加数据","depth":3,"charIndex":5224},{"text":"查询数据","id":"查询数据","depth":3,"charIndex":5338},{"text":"筛选数据","id":"筛选数据","depth":3,"charIndex":5367}],"domain":"","frontmatter":{"title":"IndexedDB 数据库","date":"2023-08-21T16:46:09.000Z"},"version":""},{"id":8,"title":"Sass 基础","content":"#\n\n\n一、注释#\n\n>  1. Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。\n> \n>  2. 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n> \n>  3. 插值语句 (interpolation) 也可写进多行注释中输出变量值\n\n\n二、变量#\n\n\n1.定义#\n\n> 变量以美元符号开头，赋值方法与 CSS 属性的写法一样\n\n\n\n\n2.使用#\n\n> 直接使用变量的名称即可调用变量\n\n\n\n\n3.作用域#\n\n> 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可\n> 以添加 !global 声明\n\n\n\n编译后：\n\n\n\n--------------------------------------------------------------------------------\n\n\n三、数据类型#\n\n> SassScript 支持 7 种主要的数据类型：\n> \n>  * 数字，1, 2, 13, 10px\n>  * 字符串，有引号字符串与无引号字符串，\"foo\", 'bar', baz\n>  * 颜色，blue, #04a3f9, rgba(255,0,0,0.5)\n>  * 布尔型，true, false\n>  * 空值，null\n>  * 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif\n>  * maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)\n> \n> SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而 Sass\n> 不会特殊对待这些属性值，一律视为无引号字符串。\n> \n> 判断数据类型的方式：type-of($value)\n\n\n1.字符串 (Strings)#\n\n> SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，和无引号字符串 (unquoted strings)。\n\n\n\n\n2.数字(Numbers)#\n\n> SassScript 支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\n\n\n\n\n3.空值(Null)#\n\n> 只有一个取值null\n\n\n\n\n4.布尔型(Booleans)#\n\n> 只有两个取值：true和false\n\n\n\n\n5.数组 (Lists)#\n\n> 通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从1开始\n\n\n\n> 数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px\n> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px\n> 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px)\n> 则使用空格分割(space-separated)。\n> \n> 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px,\n> 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n> \n> 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family:\n> () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。\n> \n> 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1\n> 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。\n\n\n6.映射(Maps)#\n\n> Maps 必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌 maps，不过不推荐这种内嵌方式）\n\n\n\n\n7.颜色 (Colors)#\n\n> CSS 原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA 和色彩单词\n> \n> SCSS 提供了内置 Colors 函数，从而更方便地使用颜色\n\n\n\n--------------------------------------------------------------------------------\n\n\n四、运算#\n\n\n1.数字运算符#\n\n> SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值\n> \n> 如果要保留运算符号，则应该使用插值语法\n\n * +\n   \n   \n   \n   \n\n * -\n   \n   \n   \n   \n\n * *\n   \n   \n   \n   \n\n * /\n   \n   \n\n * %\n   \n   \n\n\n2.关系运算符#\n\n> 大前提：两端必须为数字 或 前部分数字后部分字符\n> \n> 返回值：true or false\n\n * >\n   \n   \n\n * <\n   \n   \n\n * >=\n   \n   \n\n * <=\n   \n   \n\n\n3.相等运算符#\n\n> 作用范围：相等运算 ==, != 可用于所有数据类型\n> \n> 返回值：true or false\n\n\n\n\n\n\n4.布尔运算符#\n\n> SassScript 支持布尔型的 and or 以及 not 运算。\n\n\n\n\n5.颜色值运算#\n\n> 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值\n\n * 颜色值与颜色值\n   \n   \n\n * 颜色值与数字\n   \n   \n\n * RGB和HSL\n   \n   \n\n\n6.运算优先级#\n\n 0. ()\n\n 1. *、/、%\n\n 2. +、-\n\n 3. > 、<、>=、<=\n\n--------------------------------------------------------------------------------\n\n\n五、嵌套语法#\n\n> 此部分过于简单不计入笔记\n\n--------------------------------------------------------------------------------\n\n\n六、杂货语法#\n\n\n1.插值语法#\n\n通过 #{} 插值语句可以在选择器、属性名和属性值中使用变量。\n\n但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。\n\n\n\n\n2.& in SassScript#\n\n&为父选择器\n\n\n\n\n3.!default#\n\n可以在变量的结尾添加 !default 给一个未通过 !default\n声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n\n\n\n注意：变量是 null 空值时将视为未被 !default 赋值。\n\n\n3.!global#\n\n将局部变量提升为全局变量\n\n\n4.!optional#\n\n如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice\n选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。\n\n如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的.\n\n简而言之：当@extend相关代码出现语法错误时，编译器可能会给我们\"乱\"编译为 css，我们加上这个参数可以在出现问题后不让他编译该部分代码\n\n--------------------------------------------------------------------------------\n\n\n七、@-Rules 与指令#\n\n\n1.@import#\n\n> Sass 拓展了 @import 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS\n> 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\n> \n> 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n> \n>  * 文件拓展名是 .css；\n>  * 文件名以 http:// 开头；\n>  * 文件名是 url()；\n>  * @import 包含 media queries。\n> \n> 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或\n> .sass 的文件并将其导入。\n\n\n\n> Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n\n\n\n> 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：\n\n\n\n> 如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。\n> 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。\n> \n> 除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。\n\n\n2.@media#\n\n> Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS\n> 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS\n> 的书写流程。\n\n\n\n> @media的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and\n\n\n\n> @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值\n\n\n\n\n3.@extend#\n\n> @extend即继承。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。\n\n--------------------------------------------------------------------------------\n\n\n八、控制指令#\n\n\n1.if()#\n\n三元运算符\n\n表达式：if(expression, value1, value2)\n\n\n\n\n2.@if#\n\n条件语句\n\n当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码\n\n@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if\n声明，如果全部失败，最后执行 @else 声明\n\n * 单@if\n   \n   \n\n * @if - @else\n   \n   \n\n * @if - @else if - @else\n   \n   \n\n\n3.@for#\n\n循环语句\n\n表达式：@for $var from through 或 @for $var from to\n\nthrough 和 to 的相同点与不同点：\n\n * 相同点：两者均包含的值\n * 不同点：through 包含的值，但 to 不包含的值\n\n\n\n\n4.@while#\n\n循环语句\n\n表达式：@while expression\n\n@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到\n\n\n\n\n5.@each#\n\n循环语句\n\n表达式：$var in $vars\n\n\n\n--------------------------------------------------------------------------------\n\n\n九、混合指令#\n\n> 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分\n> Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n\n注意：这不是函数！没有返回值！！\n\n\n1.定义混合指令#\n\n混合指令的用法是在 @mixin 后添加名称与样式，以及需要的参数（可选）。\n\n\n\n\n\n\n2.引用混合样式#\n\n使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。\n\n\n\n\n\n\n3.参数#\n\n格式：按照变量的格式，通过逗号分隔，将参数写进 Mixin 名称后的圆括号里\n\n支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参\n\na. 位置传参#\n\n\n\nb.关键词传参#\n\n\n\nc.参数默认值#\n\n\n\nd.不定参数#\n\n> 官方：Variable Arguments\n> \n> 译文：参数变量\n> \n> 有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理\n\n\n\n\n4.向混合样式中导入内容#\n\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方（ 少用，逻辑容易混乱 ）\n\n\n\n--------------------------------------------------------------------------------\n\n\n十、函数指令#\n\n\n1.内置函数#\n\na. 字符串函数#\n\n> 索引第一个为 1，最后一个为-1；切片两边均为闭区间\n\n函数名和参数类型                                 函数作用\nquote($string)                           添加引号\nunquote($string)                         除去引号\nto-lower-case($string)                   变为小写\nto-upper-case($string)                   变为大写\nstr-length($string)                      返回$string 的长度(汉字算一个)\nstr-index($string，$substring)            返回$substring在$string 的位置\nstr-insert($string, $insert, $index)     在$string的$index 处插入$insert\nstr-slice($string, $start-at, $end-at）   截取$string的$start-at 和$end-at 之间的字符串\n\nb. 数字函数#\n\n函数名和参数类型                  函数作用\npercentage($number)       转换为百分比形式\nround($number)            四舍五入为整数\nceil($number)             数值向上取整\nfloor($number)            数值向下取整\nabs($number)              获取绝对值\nmin($number...)           获取最小值\nmax($number...)           获取最大值\nrandom($number?:number)   不传入值：获得 0-1 的随机数；传入正整数 n：获得 0-n 的随机整数（左开右闭）\n\nc. 数组函数#\n\n函数名和参数类型                           函数作用\nlength($list)                      获取数组长度\nnth($list, n)                      获取指定下标的元素\nset-nth($list, $n, $value)         向$list的$n 处插入$value\njoin($list1, $list2, $separator)   拼接$list1和list2；$separator 为新 list 的分隔符，默认为 auto，可选择\n                                   comma、space\nappend($list, $val, $separator)    向$list的末尾添加$val；$separator 为新 list 的分隔符，默认为 auto，可选择\n                                   comma、space\nindex($list, $value)               返回$value值在$list 中的索引值\nzip($lists…)                       将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的\n\nd. 映射函数#\n\n函数名和参数类型                  函数作用\nmap-get($map, $key)       获取$map中$key 对应的$value\nmap-merge($map1, $map2)   合并$map1和$map2，返回一个新$map\nmap-remove($map, $key)    从$map中删除$key，返回一个新$map\nmap-keys($map)            返回$map所有的$key\nmap-values($map)          返回$map所有的$value\nmap-has-key($map, $key)   判断$map中是否存在$key，返回对应的布尔值\nkeywords($args)           返回一个函数的参数，并可以动态修改其值\n\ne. 颜色函数#\n\n * RGB 函数\n   \n   函数名和参数类型                         函数作用\n   rgb($red, $green, $blue)         返回一个 16 进制颜色值\n   rgba($red,$green,$blue,$alpha)   返回一个 rgba；$red,$green 和$blue 可被当作一个整体以颜色单词、hsl、rgb 或 16\n                                    进制形式传入\n   red($color)                      从$color 中获取其中红色值\n   green($color)                    从$color 中获取其中绿色值\n   blue($color)                     从$color 中获取其中蓝色值\n   mix($color1,$color2,$weight?)    按照$weight比例，将$color1 和$color2 混合为一个新颜色\n\n * HSL 函数\n   \n   函数名和参数类型                                   函数作用\n   hsl($hue,$saturation,$lightness)           通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色\n   hsla($hue,$saturation,$lightness,$alpha)   通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色\n   saturation($color)                         从一个颜色中获取饱和度（saturation）值\n   lightness($color)                          从一个颜色中获取亮度（lightness）值\n   adjust-hue($color,$degrees)                通过改变一个颜色的色相值，创建一个新的颜色\n   lighten($color,$amount)                    通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色\n   darken($color,$amount)                     通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色\n   hue($color)                                从一个颜色中获取亮度色相（hue）值\n\n * Opacity 函数\n   \n                                                                 \n   alpha($color)/opacity($color)                                 获取颜色透明度值\n   rgba($color,$alpha)                                           改变颜色的透明度\n   opacify($color, $amount) / fade-in($color, $amount)           使颜色更不透明\n   transparentize($color, $amount) / fade-out($color, $amount)   使颜色更加透明\n\nf. Introspection 函数#\n\n函数名和参数类型                         函数作用\ntype-of($value)                  返回$value 的类型\nunit($number)                    返回$number 的单位\nunitless($number)                判断$number 是否带单位，返回对应的布尔值\ncomparable($number1, $number2)   判断$number1和$number2 是否可以做加、减和合并，返回对应的布尔值\n\n\n2.自定义函数#\n\n> Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用\n> \n> Params: 与 Mixin 一致\n> \n> 支持返回值\n\n基本格式：\n\n\n\n","routePath":"/Explorers-Notes/frontEnd/sass/base","lang":"","toc":[{"text":"一、注释","id":"一注释","depth":2,"charIndex":3},{"text":"二、变量","id":"二变量","depth":2,"charIndex":195},{"text":"1.定义","id":"1定义","depth":3,"charIndex":203},{"text":"2.使用","id":"2使用","depth":3,"charIndex":244},{"text":"3.作用域","id":"3作用域","depth":3,"charIndex":273},{"text":"三、数据类型","id":"三数据类型","depth":2,"charIndex":473},{"text":"1.字符串 (Strings)","id":"1字符串-strings","depth":3,"charIndex":916},{"text":"2.数字(Numbers)","id":"2数字numbers","depth":3,"charIndex":1019},{"text":"3.空值(Null)","id":"3空值null","depth":3,"charIndex":1090},{"text":"4.布尔型(Booleans)","id":"4布尔型booleans","depth":3,"charIndex":1120},{"text":"5.数组 (Lists)","id":"5数组-lists","depth":3,"charIndex":1162},{"text":"6.映射(Maps)","id":"6映射maps","depth":3,"charIndex":1901},{"text":"7.颜色 (Colors)","id":"7颜色-colors","depth":3,"charIndex":1974},{"text":"四、运算","id":"四运算","depth":2,"charIndex":2155},{"text":"1.数字运算符","id":"1数字运算符","depth":3,"charIndex":2163},{"text":"2.关系运算符","id":"2关系运算符","depth":3,"charIndex":2354},{"text":"3.相等运算符","id":"3相等运算符","depth":3,"charIndex":2474},{"text":"4.布尔运算符","id":"4布尔运算符","depth":3,"charIndex":2542},{"text":"5.颜色值运算","id":"5颜色值运算","depth":3,"charIndex":2594},{"text":"6.运算优先级","id":"6运算优先级","depth":3,"charIndex":2702},{"text":"五、嵌套语法","id":"五嵌套语法","depth":2,"charIndex":2839},{"text":"六、杂货语法","id":"六杂货语法","depth":2,"charIndex":2947},{"text":"1.`插值语法`","id":"1插值语法","depth":3,"charIndex":-1},{"text":"2.`& in SassScript`","id":"2-in-sassscript","depth":3,"charIndex":-1},{"text":"3.`!default`","id":"3default","depth":3,"charIndex":-1},{"text":"3.`!global`","id":"3global","depth":3,"charIndex":-1},{"text":"4.`!optional`","id":"4optional","depth":3,"charIndex":-1},{"text":"七、@-Rules 与指令","id":"七-rules-与指令","depth":2,"charIndex":3621},{"text":"1.`@import`","id":"1import","depth":3,"charIndex":-1},{"text":"2.`@media`","id":"2media","depth":3,"charIndex":-1},{"text":"3.`@extend`","id":"3extend","depth":3,"charIndex":-1},{"text":"八、控制指令","id":"八控制指令","depth":2,"charIndex":4843},{"text":"1.`if()`","id":"1if","depth":3,"charIndex":-1},{"text":"2.`@if`","id":"2if","depth":3,"charIndex":-1},{"text":"3.`@for`","id":"3for","depth":3,"charIndex":-1},{"text":"4.`@while`","id":"4while","depth":3,"charIndex":-1},{"text":"5.`@each`","id":"5each","depth":3,"charIndex":-1},{"text":"九、混合指令","id":"九混合指令","depth":2,"charIndex":5506},{"text":"1.定义混合指令","id":"1定义混合指令","depth":3,"charIndex":5649},{"text":"2.引用混合样式","id":"2引用混合样式","depth":3,"charIndex":5705},{"text":"3.参数","id":"3参数","depth":3,"charIndex":5769},{"text":"a. 位置传参","id":"a-位置传参","depth":4,"charIndex":5849},{"text":"b.关键词传参","id":"b关键词传参","depth":4,"charIndex":5861},{"text":"c.参数默认值","id":"c参数默认值","depth":4,"charIndex":5873},{"text":"d.不定参数","id":"d不定参数","depth":4,"charIndex":5885},{"text":"4.向混合样式中导入内容","id":"4向混合样式中导入内容","depth":3,"charIndex":6008},{"text":"十、函数指令","id":"十函数指令","depth":2,"charIndex":6187},{"text":"1.内置函数","id":"1内置函数","depth":3,"charIndex":6197},{"text":"a. 字符串函数","id":"a-字符串函数","depth":4,"charIndex":6206},{"text":"b. 数字函数","id":"b-数字函数","depth":4,"charIndex":6751},{"text":"c. 数组函数","id":"c-数组函数","depth":4,"charIndex":7094},{"text":"d. 映射函数","id":"d-映射函数","depth":4,"charIndex":7681},{"text":"e. 颜色函数","id":"e-颜色函数","depth":4,"charIndex":8049},{"text":"f. Introspection 函数","id":"f-introspection-函数","depth":4,"charIndex":9594},{"text":"2.自定义函数","id":"2自定义函数","depth":3,"charIndex":9881}],"domain":"","frontmatter":{"title":"Sass 基础","date":"2022-03-16T08:00:47.000Z"},"version":""},{"id":9,"title":"TypeScript 基础","content":"> 阮一峰更新了 TypeScript 的教程，内容更全易懂\n\n\nTypeScript 基础#\n\n\n一、数据类型。#\n\n\n1、布尔值#\n\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：\n\n\n\n\n2、数值#\n\n使用 number 定义数值类型：\n\n\n\n编译结果：\n\n\n\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。\n\n\n3、字符串#\n\n使用 string 定义字符串类型：\n\n\n\n编译结果：\n\n\n\n其中 ``` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。\n\n\n4、空值#\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：\n\n\n\n\n5、Null 和 Undefined#\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n\n\n\n6、任意值（ any ）#\n\n> 相当于是去掉了 Typescript 的类型强调，可以给赋任何值，也可以赋值给容易，在代码中尽量不用\n\n\n\n\n7、数组#\n\nⅠ、最简单的方法是使用「类型 + 方括号」来表示数组：#\n\n\n\n> 数组的项中不允许出现其他的类型：\n\n\n\n> 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n\n\n> 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 \"8\" 字符串类型的参数，所以报错了。\n\nⅡ、数组泛型#\n\n我们也可以使用数组泛型（Array Generic） Array 来表示数组：\n\n\n\n关于泛型，可以参考泛型一章。\n\nⅢ、用接口表示数组#\n\n接口也可以用来描述数组：\n\n\n\n> NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n> \n> 虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n> \n> 不过有一种情况例外，那就是它常用来表示类数组。\n\n\n二、类型推论#\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。\n\n\n1、什么是类型推论#\n\n> 以下代码虽然没有指定类型，但是会在编译的时候报错：\n\n\n\n> 事实上，它等价于：\n\n\n\n> TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n> \n> 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\n\n\n\n三、联合类型#\n\n> 联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n\n1、简单的例子#\n\n\n\n联合类型使用 | 分隔每个类型。\n\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string\n或者 number，但是不能是其他类型。\n\n\n四、函数的类型#\n\n\n1、函数声明#\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n\n\n注意，输入多余的（或者少于要求的）参数，是不被允许的：\n\n\n2、函数表达式#\n\n如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：\n\n\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的\nmySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：\n\n\n\n注意不要混淆了 TypeScript 中的 => 和 ES6 中的 =>。\n\n在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，=> 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。\n\n\n3、用接口定义函数的形状#\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n4、可选参数#\n\n前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\n\n\n\n\n5、参数默认值#\n\n在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：\n\n\n\n> 关于默认参数，可以参考 ES6 中函数参数的默认值。\n\n\n五、类型别名type#\n\n类型别名用来给一个类型起个新名字。\n\n\n简单的例子#\n\n\n\n上例中，我们使用 type 创建类型别名。\n\n类型别名常用于联合类型。\n\n\n六、类型断言#\n\n类型断言（Type Assertion）可以用来手动指定一个值的类型。\n\n\n1、语法#\n\n\n\n或\n\n\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n\n形如 的语法在 tsx 中表示的是一个 ReactNode，在 ts 中除了表示类型断言之外，也可能是表示一个泛型。\n\n故建议大家在使用类型断言时，统一使用 值 as 类型 这样的语法。\n\n\n2、类型断言的用途#\n\n> 将一个联合类型断言为其中一个类型\n\n之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：\n\n\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\n\n\n\n上面的例子中，获取 animal.swim 的时候会报错。\n\n此时可以使用类型断言，将 animal 断言成 Fish：\n\n\n\n这样就可以解决访问 animal.swim 时报错的问题了。\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n\n\n\n上面的例子编译时不会报错，但在运行时会报错：\n\n\n\n原因是 (animal as Fish).swim() 这段代码隐藏了 animal 可能为 Cat 的情况，将 animal 直接断言为 Fish 了，而\nTypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误。\n\n可是 swim 函数接受的参数是 Cat | Fish，一旦传入的参数是 Cat 类型的变量，由于 Cat 上没有 swim 方法，就会导致运行时错误了。\n\n总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。\n\n\n3、双重断言#\n\n既然：\n\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？\n\n\n\n在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n**除非迫不得已，千万别用双重断言。**\n\n\n4、类型断言 => 类型转换 ?#\n\n类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n\n\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\n\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\n\n\n\n七、元组#\n\n> 数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n> \n> 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。\n\n\n简单的例子#\n\n定义一对值分别为 string 和 number 的元组：\n\n\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\n\n\n\n也可以只赋值其中一项：\n\n\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\n\n\n\n\n越界的元素#\n\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\n\n\n\n\n八、枚举enum#\n\n> 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n\n\n简单的例子#\n\n枚举使用 enum 关键字来定义：\n\n\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：\n\n\n\n事实上，上面的例子会被编译为：\n\n\n\n\n手动赋值#\n\n我们也可以给枚举项手动赋值：\n\n\n\n上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。\n\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：\n\n\n\n上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 \"Sun\"，而后又被\n\"Wed\" 覆盖了。编译的结果是：\n\n\n\n所以使用的时候需要注意，最好不要出现这种覆盖的情况。\n\n手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：\n\n\n\n当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：\n\n\n\n\n常数项和计算所得项#\n\n枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。\n\n前面我们所举的例子都是常数项，一个典型的计算所得项的例子：\n\n\n\n上面的例子中，\"blue\".length 就是一个计算所得项。\n\n上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：\n\n\n\n下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举：\n\n当满足以下条件时，枚举成员被当作是常数：\n\n * 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加\n   1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。\n * 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript\n   表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n   * 数字字面量\n   * 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用\n   * 带括号的常数枚举表达式\n   * +, -, ~ 一元运算符应用于常数枚举表达式\n   * +, -, *, /, %, <<, >>, >>>, &, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN\n     或 Infinity，则会在编译阶段报错\n\n所有其它情况的枚举成员被当作是需要计算得出的值。\n\n\n常数枚举#\n\n常数枚举是使用 const enum 定义的枚举类型：\n\n\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n\n上例的编译结果是：\n\n\n\n假如包含了计算成员，则会在编译阶段报错：\n\n\n\n\n外部枚举§#\n\n外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型：\n\n\n\n之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n上例的编译结果是：\n\n\n\n外部枚举与声明语句一样，常出现在声明文件中。\n\n同时使用 declare 和 const 也是可以的：\n\n\n\n编译结果：\n\n\n\n> TypeScript 的枚举类型的概念来源于 C#。\n\n\n九、接口#\n\n> 在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n\n1、什么是接口#\n\n> 在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n> \n> TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述\n\n\n2、简单的例子#\n\n\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person\n一致。\n\n\n3、可选属性#\n\n> 有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n\n\n> 可选属性的含义是该属性可以不存在。\n\n\n4、任意属性#\n\n> 有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n\n\n> 使用 [propName: string] 定义了任意属性取 string 类型的值。\n\n\n5、只读属性#\n\n> 有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\n\n> 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n\n十、类#\n\nTypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。\n\n * public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n * private 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n * protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n下面举一些例子：\n\n\n\n上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。\n\n很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：\n\n\n\n需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。\n\n上面的例子编译后的代码是：\n\n\n\n使用 private 修饰的属性或方法，在子类中也是不允许访问的：\n\n\n\n而如果是用 protected 修饰，则允许在子类中访问：\n\n\n\n当构造函数修饰为 private 时，该类不允许被继承或者实例化：\n\n\n\n当构造函数修饰为 protected 时，该类只允许被继承：\n\n\n\n\n参数属性#\n\n修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\n\n\n\n\nreadonly#\n\n只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\n\n\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\n\n\n\n\n抽象类#\n\nabstract 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\n\n\n上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\n\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\n\n\n上面的例子中，我们实现了抽象方法 sayHi，编译通过了。\n\n需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：\n\n\n\n\n类的类型#\n\n给类加上 TypeScript 的类型很简单，与接口类似：\n\n\n\n\n十一、类与接口#\n\n接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。\n\n这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。\n\n\n类实现接口#\n\n实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（\ninterfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以\n考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\n\n\n\n一个类可以实现多个接口：\n\n\n\n上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。\n\n\n接口继承接口#\n\n接口与接口之间可以是继承关系：\n\n\n\n这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。\n\n\n接口继承类#\n\n常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：\n\n\n\n为什么 TypeScript 会支持接口继承类呢？\n\n实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。\n\n所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例）：\n\n\n\n也可以将 Point 当做一个类型来用（使用 : Point 表示参数的类型）：\n\n\n\n这个例子实际上可以等价于：\n\n\n\n上例中我们新声明的 PointInstanceType 类型，与声明 class Point 时创建的 Point 类型是等价的。\n\n所以回到 Point3d 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：\n\n\n\n当我们声明 interface Point3d extends Point 时，Point3d 继承的实际上是类 Point 的实例的类型。\n\n换句话说，可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType。\n\n所以「接口继承类」和「接口继承接口」没有什么本质的区别。\n\n值得注意的是，PointInstanceType 相比于 Point，缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point\n类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。\n\n换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法：\n\n\n\n上例中最后的类型 Point 和类型 PointInstanceType 是等价的。\n\n同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。\n\n\n十二、泛型#\n\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n\n简单的例子#\n\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\n\n\n\n上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。\n\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\n\nArray 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n\n这时候，泛型就派上用场了：\n\n\n\n上例中，我们在函数名后添加了 ，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array 中即可使用了。\n\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\n\n\n\n\n多个类型参数#\n\n定义泛型的时候，可以一次定义多个类型参数：\n\n\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n\n\n泛型约束#\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\n\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\n\n\n\n上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\n\n\n\n多个类型参数之间也可以互相约束：\n\n\n\n上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。\n\n\n泛型接口#\n\n可以使用接口的方式来定义一个函数需要符合的形状：\n\n\n\n当然也可以使用含有泛型的接口来定义函数的形状：\n\n\n\n进一步，我们可以把泛型参数提前到接口名上：\n\n\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n\n\n泛型类#\n\n与泛型接口类似，泛型也可以用于类的类型定义中：\n\n\n\n\n泛型参数的默认类型#\n\n在 TypeScript 2.3\n以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\n\n\n\n十三、声明合并#\n\n如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：\n\n\n函数的合并#\n\n我们可以使用重载定义多个函数类型：\n\n\n\n\n接口的合并#\n\n接口中的属性在合并时会简单的合并到一个接口中：\n\n\n\n相当于：\n\n\n\n注意，合并的属性的类型必须是唯一的：\n\n\n\n接口中方法的合并，与函数的合并一样：\n\n\n\n相当于：\n\n\n\n\n类的合并#\n\n类的合并与接口的合并规则一致。","routePath":"/Explorers-Notes/frontEnd/typescript/base","lang":"","toc":[{"text":"一、数据类型。","id":"一数据类型","depth":2,"charIndex":49},{"text":"1、布尔值","id":"1布尔值","depth":3,"charIndex":60},{"text":"2、数值","id":"2数值","depth":3,"charIndex":120},{"text":"3、字符串","id":"3字符串","depth":3,"charIndex":210},{"text":"4、空值","id":"4空值","depth":3,"charIndex":299},{"text":"5、Null 和 Undefined","id":"5null-和-undefined","depth":3,"charIndex":426},{"text":"6、任意值（ any ）","id":"6任意值-any-","depth":3,"charIndex":502},{"text":"7、数组","id":"7数组","depth":3,"charIndex":574},{"text":"Ⅰ、最简单的方法是使用「类型 + 方括号」来表示数组：","id":"ⅰ最简单的方法是使用类型--方括号来表示数组","depth":4,"charIndex":581},{"text":"Ⅱ、数组泛型","id":"ⅱ数组泛型","depth":4,"charIndex":732},{"text":"Ⅲ、用接口表示数组","id":"ⅲ用接口表示数组","depth":4,"charIndex":800},{"text":"二、类型推论","id":"二类型推论","depth":2,"charIndex":950},{"text":"1、什么是类型推论","id":"1什么是类型推论","depth":3,"charIndex":1006},{"text":"三、联合类型","id":"三联合类型","depth":2,"charIndex":1163},{"text":"1、简单的例子","id":"1简单的例子","depth":3,"charIndex":1210},{"text":"四、函数的类型","id":"四函数的类型","depth":2,"charIndex":1342},{"text":"1、函数声明","id":"1函数声明","depth":3,"charIndex":1353},{"text":"2、函数表达式","id":"2函数表达式","depth":3,"charIndex":1457},{"text":"3、用接口定义函数的形状","id":"3用接口定义函数的形状","depth":3,"charIndex":1768},{"text":"4、可选参数","id":"4可选参数","depth":3,"charIndex":1881},{"text":"5、参数默认值","id":"5参数默认值","depth":3,"charIndex":1964},{"text":"五、类型别名`type`","id":"五类型别名type","depth":2,"charIndex":-1},{"text":"简单的例子","id":"简单的例子","depth":3,"charIndex":2096},{"text":"六、类型断言","id":"六类型断言","depth":2,"charIndex":2144},{"text":"1、语法","id":"1语法","depth":3,"charIndex":2191},{"text":"2、类型断言的用途","id":"2类型断言的用途","depth":3,"charIndex":2351},{"text":"3、双重断言","id":"3双重断言","depth":3,"charIndex":2946},{"text":"4、类型断言  =>  类型转换 ?","id":"4类型断言----类型转换-","depth":3,"charIndex":-1},{"text":"七、元组","id":"七元组","depth":2,"charIndex":3436},{"text":"简单的例子","id":"简单的例子-1","depth":3,"charIndex":3519},{"text":"越界的元素","id":"越界的元素","depth":3,"charIndex":3652},{"text":"八、枚举`enum`","id":"八枚举enum","depth":2,"charIndex":-1},{"text":"简单的例子","id":"简单的例子-2","depth":3,"charIndex":3760},{"text":"手动赋值","id":"手动赋值","depth":3,"charIndex":3853},{"text":"常数项和计算所得项","id":"常数项和计算所得项","depth":3,"charIndex":4190},{"text":"常数枚举","id":"常数枚举","depth":3,"charIndex":4878},{"text":"外部枚举§","id":"外部枚举","depth":3,"charIndex":4992},{"text":"九、接口","id":"九接口","depth":2,"charIndex":5198},{"text":"1、什么是接口","id":"1什么是接口","depth":3,"charIndex":5252},{"text":"2、简单的例子","id":"2简单的例子","depth":3,"charIndex":5419},{"text":"3、可选属性","id":"3可选属性","depth":3,"charIndex":5518},{"text":"4、任意属性","id":"4任意属性","depth":3,"charIndex":5582},{"text":"5、只读属性","id":"5只读属性","depth":3,"charIndex":5674},{"text":"十、类","id":"十类","depth":2,"charIndex":5785},{"text":"参数属性","id":"参数属性","depth":3,"charIndex":6308},{"text":"readonly","id":"readonly","depth":3,"charIndex":6372},{"text":"抽象类","id":"抽象类","depth":3,"charIndex":6459},{"text":"类的类型","id":"类的类型","depth":3,"charIndex":6775},{"text":"十一、类与接口","id":"十一类与接口","depth":2,"charIndex":6816},{"text":"类实现接口","id":"类实现接口","depth":3,"charIndex":6898},{"text":"接口继承接口","id":"接口继承接口","depth":3,"charIndex":7213},{"text":"接口继承类","id":"接口继承类","depth":3,"charIndex":7319},{"text":"十二、泛型","id":"十二泛型","depth":2,"charIndex":8144},{"text":"简单的例子","id":"简单的例子-3","depth":3,"charIndex":8212},{"text":"多个类型参数","id":"多个类型参数","depth":3,"charIndex":8551},{"text":"泛型约束","id":"泛型约束","depth":3,"charIndex":8618},{"text":"泛型接口","id":"泛型接口","depth":3,"charIndex":8973},{"text":"泛型类","id":"泛型类","depth":3,"charIndex":9089},{"text":"泛型参数的默认类型","id":"泛型参数的默认类型","depth":3,"charIndex":9123},{"text":"十三、声明合并","id":"十三声明合并","depth":2,"charIndex":9228},{"text":"函数的合并","id":"函数的合并","depth":3,"charIndex":9274},{"text":"接口的合并","id":"接口的合并","depth":3,"charIndex":9304},{"text":"类的合并","id":"类的合并","depth":3,"charIndex":9400}],"domain":"","frontmatter":{"title":"TypeScript 基础","date":"2022-06-07T12:37:52.000Z"},"version":""},{"id":11,"title":"","content":"","routePath":"/Explorers-Notes/links/Links","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"网海指南针","content":"#\n\n\n工具#\n\n\nReact 生态#\n\n\nVue 生态#\n\n\nCSS 生态#\n\n\nNode 生态#\n\n\n跨平台框架#\n\n\n可视化#\n\n\n打包编译工具#","routePath":"/Explorers-Notes/links/","lang":"","toc":[{"text":"工具","id":"工具","depth":2,"charIndex":3},{"text":"React 生态","id":"react-生态","depth":2,"charIndex":9},{"text":"Vue 生态","id":"vue-生态","depth":2,"charIndex":21},{"text":"CSS 生态","id":"css-生态","depth":2,"charIndex":31},{"text":"Node 生态","id":"node-生态","depth":2,"charIndex":41},{"text":"跨平台框架","id":"跨平台框架","depth":2,"charIndex":52},{"text":"可视化","id":"可视化","depth":2,"charIndex":61},{"text":"打包编译工具","id":"打包编译工具","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"pageType":"doc","sidebar":false,"footer":false},"version":""},{"id":13,"title":"","content":"","routePath":"/Explorers-Notes/links/list/CSS","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"","content":"","routePath":"/Explorers-Notes/links/list/CrossPlatform","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Node","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"","content":"","routePath":"/Explorers-Notes/links/list/TOOL","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Visualization","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Vue","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"","content":"","routePath":"/Explorers-Notes/links/list/buildTools","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"","content":"","routePath":"/Explorers-Notes/links/list/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"","content":"","routePath":"/Explorers-Notes/links/list/react","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]
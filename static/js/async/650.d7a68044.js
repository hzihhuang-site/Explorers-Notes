"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["650"],{8790:function(e,n,r){r.r(n),r.d(n,{default:function(){return l}});var s=r(2676),t=r(453);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",ul:"ul",li:"li",pre:"pre",code:"code",ol:"ol"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"深入理解-typescript-装饰器",children:["深入理解 TypeScript 装饰器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深入理解-typescript-装饰器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器是 TypeScript 提供的一个强大且灵活的元编程特性，允许开发者在运行时动态地修改类、方法、属性或参数的行为。在这篇文章中，我们将深入探讨装饰器的概念、使用场景及实际应用。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-什么是装饰器",children:["1. 什么是装饰器？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-什么是装饰器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器是一个特殊的 TypeScript 元数据注解，它用于修改类、方法、属性或参数的行为。装饰器是基于 JavaScript 提案（目前为 Stage 2）的实验性功能，在 TypeScript 中可通过启用 experimentalDecorators 编译选项来使用。"}),"\n",(0,s.jsxs)(n.h3,{id:"装饰器的作用",children:["装饰器的作用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰器的作用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器允许你："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"修改类的行为或属性。"}),"\n",(0,s.jsx)(n.li,{children:"为类的属性或方法添加元数据。"}),"\n",(0,s.jsx)(n.li,{children:"在不修改原始代码的情况下增强功能。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"装饰器本质上是一种通过附加元数据或增强类行为来实现功能的方式。"}),"\n",(0,s.jsxs)(n.h2,{id:"2-如何启用装饰器",children:["2. 如何启用装饰器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-如何启用装饰器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 TypeScript 中，装饰器是一个实验性功能，所以默认情况下是禁用的。要启用装饰器，你需要在 tsconfig.json 文件中进行如下配置："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "experimentalDecorators": true\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"3-装饰器的类型",children:["3. 装饰器的类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-装饰器的类型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 TypeScript 中，装饰器分为几种类型，分别用于不同的场景。以下是常见的装饰器类型："}),"\n",(0,s.jsxs)(n.h3,{id:"31-类装饰器class-decorators",children:["3.1 类装饰器（Class Decorators）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-类装饰器class-decorators",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"类装饰器用于修改类的行为，它是一个函数，接收构造函数作为参数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function logClass(target: Function) {\n  console.log(`Class ${target.name} is created`);\n}\n\n@logClass\nclass MyClass {\n  constructor() {\n    console.log("MyClass instance created");\n  }\n}\n\nconst myClassInstance = new MyClass();\n// 输出：\n// Class MyClass is created\n// MyClass instance created\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"32-方法装饰器method-decorators",children:["3.2 方法装饰器（Method Decorators）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-方法装饰器method-decorators",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"方法装饰器用于修改类的方法，它接收三个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"target: 方法所在的类的原型。"}),"\n",(0,s.jsx)(n.li,{children:"key: 方法名。"}),"\n",(0,s.jsx)(n.li,{children:"descriptor: 方法的属性描述符。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function logMethod(target: any, key: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Method ${key} is called with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass MyClass {\n  @logMethod\n  greet(name: string) {\n    console.log(`Hello, ${name}!`);\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.greet(\"Alice\");\n// 输出：\n// Method greet is called with arguments: [ 'Alice' ]\n// Hello, Alice!\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"33-属性装饰器property-decorators",children:["3.3 属性装饰器（Property Decorators）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-属性装饰器property-decorators",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"属性装饰器用于修改类的属性，接收两个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"target: 类的构造函数。"}),"\n",(0,s.jsx)(n.li,{children:"key: 属性名。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function logProperty(target: any, key: string) {\n  let value = target[key];\n\n  const getter = () => {\n    console.log(`Getting value of ${key}: ${value}`);\n    return value;\n  };\n\n  const setter = (newValue: any) => {\n    console.log(`Setting value of ${key}: ${newValue}`);\n    value = newValue;\n  };\n\n  Object.defineProperty(target, key, { get: getter, set: setter });\n}\n\nclass MyClass {\n  @logProperty\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nconst myClass = new MyClass("Alice");\nmyClass.name = "Bob"; // 输出：Setting value of name: Bob\nconsole.log(myClass.name); // 输出：Getting value of name: Bob\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"34-参数装饰器parameter-decorators",children:["3.4 参数装饰器（Parameter Decorators）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-参数装饰器parameter-decorators",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"参数装饰器用于修改类方法的参数，它接收三个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"target: 方法所在的类的原型。"}),"\n",(0,s.jsx)(n.li,{children:"key: 方法名。"}),"\n",(0,s.jsx)(n.li,{children:"index: 参数索引。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function logParameter(target: any, key: string, index: number) {\n  console.log(`Parameter at index ${index} in method ${key} is decorated`);\n}\n\nclass MyClass {\n  greet(@logParameter name: string) {\n    console.log(`Hello, ${name}!`);\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.greet("Alice");\n// 输出：Parameter at index 0 in method greet is decorated\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"4-装饰器工厂decorator-factories",children:["4. 装饰器工厂（Decorator Factories）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-装饰器工厂decorator-factories",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器工厂是一个返回装饰器函数的函数，它允许你在装饰器中传递参数。这对于需要动态配置装饰器行为的场景非常有用。"}),"\n",(0,s.jsx)(n.p,{children:"示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function logWithPrefix(prefix: string) {\n  return function (target: any, key: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args: any[]) {\n      console.log(`${prefix} Method ${key} is called with arguments: ${args}`);\n      return originalMethod.apply(this, args);\n    };\n  };\n}\n\nclass MyClass {\n  @logWithPrefix("INFO:")\n  greet(name: string) {\n    console.log(`Hello, ${name}!`);\n  }\n}\n\nconst myClass = new MyClass();\nmyClass.greet("Alice");\n// 输出：INFO: Method greet is called with arguments: [ \'Alice\' ]\n// Hello, Alice!\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"5-装饰器的应用场景",children:["5. 装饰器的应用场景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-装饰器的应用场景",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器在多个领域有广泛的应用，以下是几个常见的场景："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"日志记录"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"使用装饰器来记录方法调用、参数和返回值，对于调试和性能监控非常有帮助。"}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"权限控制"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"可以通过装饰器在方法执行前验证权限，确保只有具有合适权限的用户才能执行特定操作。"}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"AOP（面向切面编程）"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过装饰器为方法、类添加额外的行为，类似于 AOP 中的切面，增强系统功能。"}),"\n",(0,s.jsxs)(n.h2,{id:"6-注意事项与最佳实践",children:["6. 注意事项与最佳实践",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-注意事项与最佳实践",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"装饰器是一个实验性特性，因此在生产环境中使用时需要小心。"}),"\n",(0,s.jsx)(n.li,{children:"使用装饰器时要确保它们不会过度复杂化你的代码，装饰器的目的是增强而不是替代现有的功能。"}),"\n",(0,s.jsx)(n.li,{children:"如果你需要修改类的方法或属性，优先考虑装饰器，但也要了解它可能引入的性能开销。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"7-总结",children:["7. 总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"装饰器是 TypeScript 中非常强大的功能，它为开发者提供了在运行时修改类行为和属性的能力。通过装饰器，你可以实现代码的解耦、复用，并提升代码的可维护性和可扩展性。在实际开发中，装饰器常用于日志记录、权限控制、缓存和 AOP 等场景。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["frontEnd%2Ftypescript%2Fdecorator.md"]={toc:[{text:"1. 什么是装饰器？",id:"1-什么是装饰器",depth:2},{text:"装饰器的作用",id:"装饰器的作用",depth:3},{text:"2. 如何启用装饰器",id:"2-如何启用装饰器",depth:2},{text:"3. 装饰器的类型",id:"3-装饰器的类型",depth:2},{text:"3.1 类装饰器（Class Decorators）",id:"31-类装饰器class-decorators",depth:3},{text:"3.2 方法装饰器（Method Decorators）",id:"32-方法装饰器method-decorators",depth:3},{text:"3.3 属性装饰器（Property Decorators）",id:"33-属性装饰器property-decorators",depth:3},{text:"3.4 参数装饰器（Parameter Decorators）",id:"34-参数装饰器parameter-decorators",depth:3},{text:"4. 装饰器工厂（Decorator Factories）",id:"4-装饰器工厂decorator-factories",depth:2},{text:"5. 装饰器的应用场景",id:"5-装饰器的应用场景",depth:2},{text:"6. 注意事项与最佳实践",id:"6-注意事项与最佳实践",depth:2},{text:"7. 总结",id:"7-总结",depth:2}],title:"装饰器",headingTitle:"深入理解 TypeScript 装饰器",frontmatter:{title:"装饰器",date:"2024-12-27T17:00:00.000Z"}}}}]);
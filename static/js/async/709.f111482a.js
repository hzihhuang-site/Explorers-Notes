"use strict";(self.webpackChunkrspress_doc_template=self.webpackChunkrspress_doc_template||[]).push([["709"],{8979:function(e,r,n){n.r(r),n.d(r,{default:function(){return d}});var s=n(2676),i=n(453);function t(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",h3:"h3",pre:"pre",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"javascript-观察者-api",children:["JavaScript 观察者 API",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-观察者-api",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["在现代 Web 开发中，观察者模式是一种非常重要的设计模式，它允许我们监听和响应对象的变化。JavaScript 提供了几种强大的观察者 API，使得我们能够轻松地处理 DOM 变化、视口变化、元素尺寸变化等各种动态场景。本文将介绍四种常见的观察者 API：",(0,s.jsx)(r.code,{children:"MutationObserver"}),"、",(0,s.jsx)(r.code,{children:"IntersectionObserver"}),"、",(0,s.jsx)(r.code,{children:"ResizeObserver"})," 和 ",(0,s.jsx)(r.code,{children:"PerformanceObserver"}),"。"]}),"\n",(0,s.jsxs)(r.h2,{id:"1-mutationobserver监听-dom-变动",children:["1. ",(0,s.jsx)(r.strong,{children:"MutationObserver：监听 DOM 变动"}),(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1-mutationobserver监听-dom-变动",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"11-什么是-mutationobserver",children:["1.1 什么是 ",(0,s.jsx)(r.code,{children:"MutationObserver"}),"？",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#11-什么是-mutationobserver",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"MutationObserver"})," 是一个用于观察 DOM 树变化的 API。当 DOM 中的元素发生变化时（如添加、删除子节点或更改属性等），",(0,s.jsx)(r.code,{children:"MutationObserver"})," 可以发出通知。这在某些场景下非常有用，例如，当我们想要在某些 DOM 元素变化时自动触发某些操作时。"]}),"\n",(0,s.jsxs)(r.h3,{id:"12-典型用法",children:["1.2 典型用法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#12-典型用法",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们可以创建一个 ",(0,s.jsx)(r.code,{children:"MutationObserver"})," 实例，并通过指定配置来监听特定的 DOM 变化。以下是一个基本示例："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const observer = new MutationObserver((mutationsList) => {\n  mutationsList.forEach((mutation) => {\n    if (mutation.type === "childList") {\n      console.log("子节点发生变化");\n    } else if (mutation.type === "attributes") {\n      console.log("元素属性发生变化");\n    }\n  });\n});\n\nconst config = { attributes: true, childList: true, subtree: true };\nobserver.observe(document.body, config);\n\n// 停止观察\n// observer.disconnect();\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"13-常见用途",children:["1.3 常见用途",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#13-常见用途",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"监听 DOM 结构的动态变化"}),"\n",(0,s.jsx)(r.li,{children:"监听元素属性的变化，如 class、style 等"}),"\n",(0,s.jsx)(r.li,{children:"适用于处理由 JavaScript 动态生成的内容"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"2-intersectionobserver监听元素与视口交集",children:["2. ",(0,s.jsx)(r.strong,{children:"IntersectionObserver：监听元素与视口交集"}),(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2-intersectionobserver监听元素与视口交集",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"21-什么是-intersectionobserver",children:["2.1 什么是 ",(0,s.jsx)(r.code,{children:"IntersectionObserver"}),"？",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#21-什么是-intersectionobserver",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"IntersectionObserver"})," 用于监听元素与视口（或其他元素）的交叉情况。它常用于实现懒加载、无限滚动等功能，能够在元素进入或离开视口时触发回调函数，从而做出响应。"]}),"\n",(0,s.jsxs)(r.h3,{id:"22-典型用法",children:["2.2 典型用法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#22-典型用法",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们可以使用 ",(0,s.jsx)(r.code,{children:"IntersectionObserver"})," 来监听某个元素是否进入视口，并执行相应的操作。例如："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const observer = new IntersectionObserver(\n  (entries) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        console.log("元素进入视口");\n      } else {\n        console.log("元素离开视口");\n      }\n    });\n  },\n  { threshold: 0.5 }\n);\n\nconst target = document.querySelector("#target");\nobserver.observe(target);\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"23-常见用途",children:["2.3 常见用途",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#23-常见用途",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"实现懒加载：当图片或其他内容进入视口时才加载"}),"\n",(0,s.jsx)(r.li,{children:"无限滚动：当页面滚动到底部时，加载更多内容"}),"\n",(0,s.jsx)(r.li,{children:"实现可视区域检测：例如，判断广告元素是否完全进入视口"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"3-resizeobserver监听元素尺寸变化",children:["3. ",(0,s.jsx)(r.strong,{children:"ResizeObserver：监听元素尺寸变化"}),(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3-resizeobserver监听元素尺寸变化",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"31-什么是-resizeobserver",children:["3.1 什么是 ",(0,s.jsx)(r.code,{children:"ResizeObserver"}),"？",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#31-什么是-resizeobserver",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"ResizeObserver"})," 允许我们监听元素的尺寸变化，它能够在元素大小发生变化时触发回调，常用于响应式设计中，帮助我们在窗口或元素大小改变时进行调整。"]}),"\n",(0,s.jsxs)(r.h3,{id:"32-典型用法",children:["3.2 典型用法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#32-典型用法",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们可以通过 ",(0,s.jsx)(r.code,{children:"ResizeObserver"})," 来监控元素尺寸的变化，并根据变化调整布局或执行其他操作："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const observer = new ResizeObserver((entries) => {\n  entries.forEach((entry) => {\n    console.log("元素尺寸变化:", entry.contentRect);\n  });\n});\n\nconst target = document.querySelector("#target");\nobserver.observe(target);\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"33-常见用途",children:["3.3 常见用途",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#33-常见用途",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"响应式设计：根据元素的尺寸变化调整布局"}),"\n",(0,s.jsx)(r.li,{children:"动态调整元素位置或大小：例如，调整视频播放器的大小"}),"\n",(0,s.jsx)(r.li,{children:"监控布局变化，确保 UI 元素始终在正确的位置"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"4-performanceobserver监听性能相关事件",children:["4. ",(0,s.jsx)(r.strong,{children:"PerformanceObserver：监听性能相关事件"}),(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#4-performanceobserver监听性能相关事件",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"41-什么是-performanceobserver",children:["4.1 什么是 ",(0,s.jsx)(r.code,{children:"PerformanceObserver"}),"？",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#41-什么是-performanceobserver",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"PerformanceObserver"})," 是用于监控性能相关事件的 API。它可以监听浏览器的性能信息，如资源加载、页面渲染时间等。该 API 主要用于性能分析和优化。"]}),"\n",(0,s.jsxs)(r.h3,{id:"42-典型用法",children:["4.2 典型用法",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#42-典型用法",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["我们可以使用 ",(0,s.jsx)(r.code,{children:"PerformanceObserver"})," 来监听性能相关的条目，例如资源加载、页面加载等："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const observer = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach((entry) => {\n    console.log(entry);\n  });\n});\n\nobserver.observe({ entryTypes: ["resource", "navigation"] });\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"43-常见用途",children:["4.3 常见用途",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#43-常见用途",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"页面加载性能分析：监控页面加载时间、资源加载时间"}),"\n",(0,s.jsxs)(r.li,{children:["优化页面渲染：分析关键渲染指标，如 ",(0,s.jsx)(r.code,{children:"first-contentful-paint"})," (FCP)"]}),"\n",(0,s.jsx)(r.li,{children:"资源加载优化：监控图片、脚本等静态资源的加载情况"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"5-总结",children:["5. ",(0,s.jsx)(r.strong,{children:"总结"}),(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#5-总结",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"JavaScript 中的观察者 API 提供了灵活、性能高效的方式来监听 DOM 变化、元素交集、尺寸变化和性能数据。使用这些 API，可以帮助我们构建更具响应性和高效的 Web 应用。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"MutationObserver"})})," 用于监听 DOM 结构的变化"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"IntersectionObserver"})})," 用于监听元素与视口的交集"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"ResizeObserver"})})," 用于监听元素尺寸的变化"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"PerformanceObserver"})})," 用于监听性能相关的事件"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"这些 API 的使用可以提升应用性能，减少不必要的资源消耗，并增强用户体验。掌握这些工具，将帮助开发者更好地处理动态内容和性能问题。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["frontEnd%2Fjavascript%2Fobserver.md"]={toc:[{text:"1. **MutationObserver：监听 DOM 变动**",id:"1-mutationobserver监听-dom-变动",depth:2},{text:"1.1 什么是 `MutationObserver`？",id:"11-什么是-mutationobserver",depth:3},{text:"1.2 典型用法",id:"12-典型用法",depth:3},{text:"1.3 常见用途",id:"13-常见用途",depth:3},{text:"2. **IntersectionObserver：监听元素与视口交集**",id:"2-intersectionobserver监听元素与视口交集",depth:2},{text:"2.1 什么是 `IntersectionObserver`？",id:"21-什么是-intersectionobserver",depth:3},{text:"2.2 典型用法",id:"22-典型用法",depth:3},{text:"2.3 常见用途",id:"23-常见用途",depth:3},{text:"3. **ResizeObserver：监听元素尺寸变化**",id:"3-resizeobserver监听元素尺寸变化",depth:2},{text:"3.1 什么是 `ResizeObserver`？",id:"31-什么是-resizeobserver",depth:3},{text:"3.2 典型用法",id:"32-典型用法",depth:3},{text:"3.3 常见用途",id:"33-常见用途",depth:3},{text:"4. **PerformanceObserver：监听性能相关事件**",id:"4-performanceobserver监听性能相关事件",depth:2},{text:"4.1 什么是 `PerformanceObserver`？",id:"41-什么是-performanceobserver",depth:3},{text:"4.2 典型用法",id:"42-典型用法",depth:3},{text:"4.3 常见用途",id:"43-常见用途",depth:3},{text:"5. **总结**",id:"5-总结",depth:2}],title:"JavaScript 观察者 API",headingTitle:"JavaScript 观察者 API",frontmatter:{title:"JavaScript 观察者 API",date:"2024-12-27T16:00:00.000Z"}}}}]);
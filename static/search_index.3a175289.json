[{"id":0,"title":"👋 关于我","content":"#\n\n欢迎来到我的博客！我是 一名来自江西的前端程序员，正在向全栈开发的道路迈进。这里记录了我的技术成长，希望与你一同见证每一步进步。\n\n\n🌟 我的兴趣#\n\n * ✈️ 旅游：旅行让我看到更广阔的世界，也找到更多灵感。\n * 🌊 看海：面对浩瀚的海洋，总能让我思考人生。\n * 🎮 游戏：热爱在 英雄联盟 的战场中秀操作，也喜欢在《我的世界》里建造梦想国度。\n\n\n🔧 我的专业技能#\n\n * 前端技术：React, Vue3, Next.js, TailwindCSS, Vite, Webpack, Sass, Typescript。\n * 后端开发：NestJS、MySQL、Docker 和 Nginx。\n\n\n🌐 我的作品#\n\n除了这个博客，我还维护了一些技术站点：\n\n * 📦 H-Design —— 一个基于 React 的组件库，用于提升开发效率。\n * 🛠️ H-Tools —— 基于 Vue3 开发的实用工具箱，适合日常开发需求。\n\n\n🎯 我的目标#\n\n我的职业目标是成为一名全栈型技术人才，不仅熟练掌握前后端开发，还能独立完成从需求到部署的完整项目实现。\n\n未来，我希望能通过编程实现经济自由，并拥有更多的时间去探索世界、享受生活。同时，我也希望用技术创造价值，解决实际问题，让代码成为改变世界的小力量。","routePath":"/Explorers-Notes/about","lang":"","toc":[{"text":"🌟 我的兴趣","id":"-我的兴趣","depth":2,"charIndex":69},{"text":"🔧 我的专业技能","id":"-我的专业技能","depth":2,"charIndex":184},{"text":"🌐 我的作品","id":"-我的作品","depth":2,"charIndex":311},{"text":"🎯 我的目标","id":"-我的目标","depth":2,"charIndex":433}],"domain":"","frontmatter":{"layout":"page"},"version":""},{"id":1,"title":"CSS3 counter 计数器","content":"","routePath":"/Explorers-Notes/frontEnd/css/clip-path","lang":"","toc":[],"domain":"","frontmatter":{"title":"CSS3 counter 计数器","date":"2023-08-17T10:28:00.000Z"},"version":""},{"id":2,"title":"container 容器查询","content":"#\n\n\n1. 什么是容器查询？#\n\n容器查询（Container Queries）是 CSS\n中的一项新功能，它可以根据一个容器元素的尺寸来改变该元素内部内容的样式，而不仅仅是基于视口（浏览器窗口）尺寸。这样，我们就能创建更加灵活和自适应的布局。\n\n\n示例：#\n\n假设有一个容器宽度变化的卡片组件，我们可以使用容器查询调整卡片样式：\n\n\n\n\n2. 如何使用容器查询？#\n\n\n2.1 启用容器查询#\n\n首先，容器元素需要声明 contain 属性，才能作为容器查询的参考元素。\n\n\n\n\n2.2 容器查询的基本语法#\n\n容器查询语法类似于媒体查询，我们可以根据容器的宽度、高度来应用不同的样式。\n\n\n\n\n3. 容器查询的实际应用#\n\n\n3.1 响应式组件设计#\n\n容器查询可以让我们设计响应式的组件，而不需要依赖视口的大小。比如在一个组件的容器变宽时，我们调整它的布局和样式。\n\n\n\n\n3.2 适应不同容器的布局#\n\n容器查询也可以帮助调整组件内的元素布局，比如在一个容器内，网格布局可以根据容器的宽度来改变列数。\n\n\n\n\n4. 总结#\n\n容器查询让我们能够根据容器的尺寸来动态调整布局和样式，而不依赖于视口。这使得响应式设计更加灵活和精细，特别是对于组件级别的设计。","routePath":"/Explorers-Notes/frontEnd/css/container","lang":"","toc":[{"text":"1. 什么是容器查询？","id":"1-什么是容器查询","depth":2,"charIndex":3},{"text":"示例：","id":"示例","depth":3,"charIndex":125},{"text":"2. 如何使用容器查询？","id":"2-如何使用容器查询","depth":2,"charIndex":170},{"text":"2.1 启用容器查询","id":"21-启用容器查询","depth":3,"charIndex":186},{"text":"2.2 容器查询的基本语法","id":"22-容器查询的基本语法","depth":3,"charIndex":241},{"text":"3. 容器查询的实际应用","id":"3-容器查询的实际应用","depth":2,"charIndex":299},{"text":"3.1 响应式组件设计","id":"31-响应式组件设计","depth":3,"charIndex":315},{"text":"3.2 适应不同容器的布局","id":"32-适应不同容器的布局","depth":3,"charIndex":390},{"text":"4. 总结","id":"4-总结","depth":2,"charIndex":459}],"domain":"","frontmatter":{"title":"container 容器查询","date":"2023-08-18T10:18:00.000Z"},"version":""},{"id":3,"title":"CSS3 counter 计数器","content":"#\n\nCSS计数器（counter）属性允许我们自动对页面上的元素进行编号，这在创建有序列表或章节标题时非常有用。\n\n\n什么是CSS计数器？#\n\nCSS计数器是一组用于自动递增编号的数据，它们可以通过CSS规则来增加、重置或显示。\n\n\n如何使用CSS计数器？#\n\n使用CSS计数器通常涉及以下步骤：\n\n 1. 定义一个计数器\n 2. 使用 counter-increment 属性递增计数器\n 3. 使用 content 属性和 counter() 或 counters() 函数来显示计数器的值\n\n下面我们将创建一个包含主列表项和子列表项的有序列表，并使用CSS计数器为它们自动编号。\n\n\n定义CSS样式#\n\n首先，我们定义CSS样式。\n\n\n\n\n创建HTML结构#\n\n接下来，我们创建列表的HTML结构。\n\n\n\n\n试一试#\n\n试试看，自己动手探索一下吧","routePath":"/Explorers-Notes/frontEnd/css/counter","lang":"","toc":[{"text":"什么是CSS计数器？","id":"什么是css计数器","depth":2,"charIndex":59},{"text":"如何使用CSS计数器？","id":"如何使用css计数器","depth":2,"charIndex":117},{"text":"定义CSS样式","id":"定义css样式","depth":3,"charIndex":295},{"text":"创建HTML结构","id":"创建html结构","depth":3,"charIndex":323},{"text":"试一试","id":"试一试","depth":2,"charIndex":357}],"domain":"","frontmatter":{"title":"CSS3 counter 计数器","date":"2023-08-17T10:28:00.000Z"},"version":""},{"id":4,"title":"CSS 邪门左道","content":"#\n\n\naaa222#\n\n\nbbb333#","routePath":"/Explorers-Notes/frontEnd/css/evil","lang":"","toc":[{"text":"aaa222","id":"aaa222","depth":3,"charIndex":3},{"text":"bbb333","id":"bbb333","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"CSS 邪门左道","date":"2024-10-28T12:00:00.000Z"},"version":""},{"id":5,"title":"Masonry 瀑布流","content":"#\n\n> 大概是今年 23 年 5 月份左右，在遇到的一个实现 Masonry 的问题，现在过了段时间在这里再讨论一下实现方案以及一些优缺点。\n\n\n介绍#\n\n> 瀑布流是一种很受图片网站欢迎的布局方式，英文名: Masonry Layout\n> \n> 特点: 内容由不同高度的方格从左到右自上而下依次排列组成。有种参差不齐又缺又很整齐的感觉。 以下站点皆是瀑布流布局的例子\n\n * Pexels\n * 花瓣网\n * Pinterset\n * Civitai\n\n\nJS 实现#\n\n> 自己写或是加载其他人已经写好的库。目前这种方式是最容易也最完美的方案\n\n原理基本上都是通过 JavaScript 计算共有多少个卡片，再计算每个卡片的宽度和高度，因父容器的宽度每行放置多少个卡片等等要求。将全部卡片的\nposition 都设置成 absolute 逐一计算去 top 和 left 定位。\n\n由于所有卡片位置都是计算出来的，所以还能在父容器宽度改变的时候，将卡片动态移动并且重新排列。\n\n唯一的不足是因为介入了太多的计算，卡片多的时候不建议根据父元素宽度动态重新排列，否则可能会出现卡顿现象。并且由于计算需要时间完成，在完成之前卡片并未设置位置，所\n以基本上都堆叠在左上角了\n\n * 原生: Masonry.js、Isotope.js\n\n * React：react-responsive-masonry、react-masonry-component\n\n * Vue: vue-waterfall、vue-waterfall-easy、vue-virtual-collection、vue-grid-layout\n\n\nCSS 实现#\n\n> CSS 直接支持，性能优秀。\n\n\n多列布局#\n\n\n\n> 只需要两行代码就能实现。但是它有一个缺陷，就是只能从上到下，再从左到右排列。\n> \n> 如果我们想列出的内容是根据时间由新至旧排列，这样的排列顺序就未必合适了。我们辉期望它是由左到右，再由上到下排列。\n\n案例一\n\n\nFlex 布局#\n\n> 利用 flex 竖着排列，固定容器高度让它自动换行实现，如果想要完美展示需要我们计算最合适的容器高度。\n> \n> 缺陷同上\n> \n> 但是由于 flex 中有一个 order 的属性，可以让我们自己控制图片的排列顺序，所以可控性会高一点，甚至经过计算后也能实现 从左到右，从上至下的排列\n\n\n\n案例二\n\n\nGrid 布局新特性（实验阶段）#\n\n> grid-template-rows: masonry; 可在 火狐浏览器（开启实验模式） 中试用\n\n\n\n\n结尾#\n\n> 最后可以看出，Masonry 完美的解决方法还未出现，都有各自的优劣势，不过现在用 js 会比较方便功能性会强。 很多使用 js 实现 Masonry\n> 网站都基本上限制了他的动态设置列数，或者延迟计算（等待容器宽度变化停止后）。主要是当卡片变多的时候动态计算会大幅度影响性能，所以限制列数或者延迟计算是必要的\n> 。\n\n * 花瓣网 没有限制，在浏览器大小变化时会卡顿是一个很好的例子。\n * Pexels 则是限制了它的变化。\n * Civitai 进行了延迟计算，等待容器宽度停止变化后再计算变化。","routePath":"/Explorers-Notes/frontEnd/css/masonry","lang":"","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":73},{"text":"JS 实现","id":"js-实现","depth":2,"charIndex":230},{"text":"CSS 实现","id":"css-实现","depth":2,"charIndex":708},{"text":"多列布局","id":"多列布局","depth":3,"charIndex":736},{"text":"Flex 布局","id":"flex-布局","depth":3,"charIndex":855},{"text":"Grid 布局新特性（实验阶段）","id":"grid-布局新特性实验阶段","depth":3,"charIndex":1020},{"text":"结尾","id":"结尾","depth":2,"charIndex":1095}],"domain":"","frontmatter":{"title":"Masonry 瀑布流","date":"2023-08-18T10:18:00.000Z"},"version":""},{"id":6,"title":"SVG 深入浅出","content":"#\n\n\n一、SVG 简介#\n\n> Scalable Vector Graphics —— 可缩放的矢量图\n> \n> SVG 是 W3C 推出的基于 XML 的二维矢量图形标准，也就是一种用于描述二维的矢量图形。SVG 可以提供高质量的矢量图形渲染，同时由于支持\n> JavaScript 和文档对象模型，SVG 图形通常具有强大的交互能力。\n\n\n1、SVG 的优势#\n\n * SVG 是可伸缩的，并且伸缩不会对图像质量造成影响，而一般普通的图像放大或者缩小容易导致变形，例如 JPG 或 PNG 等。\n * SVG 图像可在任何的分辨率下被高质量地打印。\n * SVG 图像可被多种工具读取和修改，例如文本编辑器等。\n * SVG 图像可被搜索、索引、脚本化或压缩 。\n * SVG 图像与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。\n * SVG 可以与 Java 技术一起运行。\n\n\n2、SVG 的使用方式#\n\n * 直接在 HTML 中作为 标签使用。\n * 在 HTML 中通过 标签来引用。\n * 通过浏览器直接打开 SVG 文件。\n * 可以作为 CSS 背景使用。\n\n\n二、学习如何编写 SVG#\n\n\n1、所有的图形都要求写在 svg 中。#\n\n\n2、基本图形、属性、API#\n\n> 基本图形 —— 、、、、、\n\nrect —— 矩形\n\n\n\ncircle —— 圆\n\n\n\nellipse —— 椭圆\n\n\n\nline —— 线\n\n\n\npolyline —— 折线\n\n\n\npolygon —— 多边形\n\n\n\n> 基本属性 —— fill、stroke、stroke-width、transform\n\n * fill —— 填充颜色\n * stroke —— 描边颜色\n * stroke-width —— 描边厚度\n * transform —— 类似于 CSS3 的 transform\n\n> 基本操作 API\n\n\n\n\n3、分组标签#\n\n * 标签来创建\n * 分组标签上的属性会被子标签继承\n * 使用 transform 属性定义分组坐标的变化\n * 分组标签可以嵌套\n\n\n\n\n4、颜色、渐变和笔刷#\n\nⅠ、认识 RGB 和 HSL#\n\n> RGB —— 不符合人类描述颜色的习惯\n\n * 红色、绿色、蓝色三个分量\n\n * 格式：rgb( r, g, b ) 或 #rrggbb\n\n * 每个分量取值范围：[ 0, 255 ]\n\n * 优势：显示器容易解析\n\n> HSL —— 符合人类描述颜色的习惯\n\n * 颜色、饱和度、亮度三个分量\n * 格式：hsl( h, s%, l%)\n * 取值范围：\n   * h: [ 0, 359 ]\n   * s，l: [0, 100 ]\n\nⅡ、渐变#\n\n> 线性渐变\n\n先看代码 —— 其实很容易懂~\n\n\n\n—— 相当于一个容器，里面存放的就是像渐变一样的工具标签\n\n—— 线性渐变标签\n\n\n\n—— 渐变的颜色切换\n\n\n\n> 径向渐变\n\n\n\n> 笔刷 —— 自定义背景\n\n\n\n使用此标签定义好一个背景，可以被其他图形以 fill 的形式调用，成为那个图形的背景\n\n\n三、Path 的使用 （高级）#\n\n\n1、Path 概述#\n\n> 一个强大的绘图工具\n> \n> 规范： http://www.w3.org/TR/SVG11/paths.html\n> \n> 由命令及其参数组成的字符串\n\n命令基本规律\n\n * 区分大小写：大写表示坐标参数为绝对位置，小写则为相对位置\n * 最后的参数表示最终要到达的位置\n * 上一个命令结束的位置就是下一个命令开始的位置\n * 命令可以重复表示重复执行同一条命令\n\n\n2、移动和直线命令#\n\n * M (x, y)+ 移动画笔，后面如果由重复参数，会当作是 L 命令处理\n * L (x, y)+ 绘制直线到指定位置\n * H (x)+ 绘制水平线到指定的 x 位置\n * V (y)+ 绘制竖直线到指定的 y 位置\n * m、l、h、v 使用相对位置绘制\n\n\n\n\n3、弧线命令#\n\n> A ( rx, ry xr, laf, sf, x, y ) —— 绘制弧线\n\n * rx - ( radius-x ) 弧线所在椭圆的 x 半轴长\n * ry - ( radius-y ) 弧线所在椭圆的 y 半轴长\n * xr - ( xAxis-rotation ) 弧线所在椭圆的长轴角度\n * laf - ( large-arc-flag ) 是否选择弧长较长的那一段弧\n * sf - ( sweep-flag ) 是否选择逆时针方向的那一段弧\n * x，y - 弧的终点位置\n\n\n\n\n4、贝塞尔曲线命令#\n\nQ(x1 y1 x y) —— 二次贝塞尔曲线\n\nC(x1 y1 x2 y2 x y) —— 三次贝塞尔曲线\n\n\n\n\n四、SVG 文本#\n\n\n1、text 和 tspan 创建文本#\n\n\n\n * 使用方法\n\n\n\n\n3、a - 插入超链接#\n\n> 使用方式与 html 中的 a 标签基本一致\n\n * 可以添加在任何的图形上\n * xlink:href 指定连接地址\n * xlink:title 指定连接提示\n * target 指定打开目标\n\n\n五、图形的引用、裁切和蒙蔽#\n\n\n1、clip - 裁切图像#\n\n> clipPath 定义裁切路径 —— 路径为两个图形的重合处\n\n\n\n> 图形上加 clip-path 属性指定此块区域被显示出来，其余部分被裁减\n\n\n\n\n2、mask - 创建蒙板#\n\n> mask 标签定义蒙板\n\n\n\n> 图形添加 mask 属性绑定蒙板\n\n\n\n\n六、SVG 动画#\n\n> svg动画有两种方式绑定要进行动画的元素\n> \n> xlink:href=\"url(#id)\"\n> \n> 直接写在 元素标签里\n\n\n1、animate#\n\n\n\n\n2、animateTransform#\n\n> 用法与上面一致，是对 transform 属性的动画修改\n\n\n3、animateMotion#\n\n","routePath":"/Explorers-Notes/frontEnd/html/svg","lang":"","toc":[{"text":"一、SVG 简介","id":"一svg-简介","depth":2,"charIndex":3},{"text":"1、SVG 的优势","id":"1svg-的优势","depth":3,"charIndex":172},{"text":"2、SVG  的使用方式","id":"2svg--的使用方式","depth":3,"charIndex":-1},{"text":"二、学习如何编写 SVG","id":"二学习如何编写-svg","depth":2,"charIndex":500},{"text":"1、所有的图形都要求写在 svg 中。","id":"1所有的图形都要求写在-svg-中","depth":3,"charIndex":516},{"text":"2、基本图形、属性、API","id":"2基本图形属性api","depth":3,"charIndex":539},{"text":"3、分组标签","id":"3分组标签","depth":3,"charIndex":824},{"text":"4、颜色、渐变和笔刷","id":"4颜色渐变和笔刷","depth":3,"charIndex":905},{"text":"Ⅰ、认识 RGB 和 HSL","id":"ⅰ认识-rgb-和-hsl","depth":4,"charIndex":918},{"text":"Ⅱ、渐变","id":"ⅱ渐变","depth":4,"charIndex":1156},{"text":"三、Path 的使用 （高级）","id":"三path-的使用-高级","depth":2,"charIndex":1319},{"text":"1、Path 概述","id":"1path-概述","depth":3,"charIndex":1338},{"text":"2、移动和直线命令","id":"2移动和直线命令","depth":3,"charIndex":1537},{"text":"3、弧线命令","id":"3弧线命令","depth":3,"charIndex":1686},{"text":"4、贝塞尔曲线命令","id":"4贝塞尔曲线命令","depth":3,"charIndex":1946},{"text":"四、SVG 文本","id":"四svg-文本","depth":2,"charIndex":2017},{"text":"1、text 和  tspan  创建文本","id":"1text-和--tspan--创建文本","depth":3,"charIndex":-1},{"text":"3、a - 插入超链接","id":"3a---插入超链接","depth":3,"charIndex":2065},{"text":"五、图形的引用、裁切和蒙蔽","id":"五图形的引用裁切和蒙蔽","depth":2,"charIndex":2182},{"text":"1、clip - 裁切图像","id":"1clip---裁切图像","depth":3,"charIndex":2199},{"text":"2、mask - 创建蒙板","id":"2mask---创建蒙板","depth":3,"charIndex":2294},{"text":"六、SVG 动画","id":"六svg-动画","depth":2,"charIndex":2350},{"text":"1、animate","id":"1animate","depth":3,"charIndex":2429},{"text":"2、animateTransform","id":"2animatetransform","depth":3,"charIndex":2444},{"text":"3、animateMotion","id":"3animatemotion","depth":3,"charIndex":2498}],"domain":"","frontmatter":{"title":"SVG 深入浅出","date":"2022-12-07T18:57:32.000Z"},"version":""},{"id":7,"title":"IndexedDB 数据库","content":"#\n\n\n简介#\n\n\n背景#\n\n随着浏览器的处理能力不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少用户等待从服务器获取数据的时间。\n\n现有的浏览器端数据储存方案，都不适合储存大量数据。\n\n * cookie 不超过 4KB，且每次请求都会发送回服务器端\n * Window.name 属性缺乏安全性，且没有统一的标准\n * localStorage/sessionStorage 在 2.5MB 到 10MB 之间（各家浏览器不同）\n\n所以，需要一种新的解决方案，这就是IndexedDB诞生的背景。\n\n\n特点:#\n\n简单的说 IndexedDB 就是浏览器端数据库。它可以被网页脚本程序创建和操作。允许储存大量数据，提供查找接口，还能建立索引。 这些都是\nlocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\n\n 1. 键值对储存:\n\n> IndexedDB内部采用对象仓库（object\n> store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。在对象仓库中，数据以“键值对”的形式保存，每一个数据都有对应的键名，键名是\n> 独一无二的，不能有重复，否则会抛出一个错误。\n\n 2. 异步:\n\n> IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与localStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写\n> ，拖慢网页的表现。\n\n 3. 支持事务:\n\n> IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回到事务发生之前的状态，不存在只改\n> 写一部分数据的情况。\n\n 4. 同源策略:\n\n> IndexedDB也受到同源策略，每一个数据库对应创建该数据库的域名。来自不同域名的网页，只能访问自身域名下的数据库，而不能访问其他域名下的数据库。\n\n 5. 储存空间大:\n\n> IndexedDB的储存空间比localStorage大得多，一般来说不少于250MB。IE的储存上限是250MB，Chrome和Opera是剩余空间的某个\n> 百分比，Firefox则没有上限。\n\n 6. 支持二进制储存:\n\n> IndexedDB不仅可以储存字符串，还可以储存二进制数据。\n\n\n基本流程#\n\n\n前置#\n\n> 你需要知道:\n> \n>  1. 你可以在同一站点上创建多个 indexedDB(数据库)\n>  2. 每个数据下面也可以创建多个 objectStore(表)\n>  3. 每个表里面的数据是 key value 键值对的形式，且value值可以是：字符串、布尔、数组、对象、二进制等类型\n>  4. 异步！！！操作基本都是异步，需要繁琐的监听事件\n\n\n连接数据库#\n\n想要在 indexedDB 里面存储数据，需要两个步骤:\n\n 1. 连接(打开)数据库\n 2. 选择需要对哪个表 objectStore(表) 进行数据操作\n\n\n\n上面代码表示，打开一个名为 mydb、版本为 1 的数据库。如果该数据库不存在，则会新建该数据库。如果省略第二个参数，则会自动创建版本为1的该数据库。 open\n方法有两个参数:\n\n 1. name: 数据库名称(string)\n 2. version: 版本，是一个大于0的正整数（0将报错）\n\n打开数据库的结果是有可能触发 4 种事件\n\n * success: 打开成功\n * error: 打开失败\n * upgradeneeded: 第一次打开该数据库 or 数据库 版本 发生变化\n * blocked: 上一次的数据库连接还未关闭\n\n第一次打开数据库会先触发 upgradeneeded 再触发 success 事件。(每次版本升级同) ps: 版本只能升不能降\n\n\n\n * open 方法返回的是一个对象（IDBOpenDBRequest），回调函数定义在这个对象上面。\n * 回调函数接受一个事件对象 event 作为参数，它的 target.result 属性就指向打开的IndexedDB数据库。\n\n\n创建数据表#\n\n获取到数据库实例后，就能通过实例对象操作数据表了\n\n\n\n上面代码创建了一个名为 firstTable 的对象仓库。\n\n此方法还可以接受第二个对象参数，用来设置 表 的属性\n\n\n\n如果该对象仓库已经存在，就会抛出一个错误。可以通过 objectStoreNames 属性来检测错误。 objectStoreNames\n属性返回了当前数据库所有 表 的名称。可以使用 contains 方法，检查数据库是否包含某个 表\n\n\n\n\n数据库事务#\n\n> 因为数据库的特性，防止我们在改变数据的过程中突然中断了，会自动直接取消本次修改。 所以每次操作数据之前都必须创建数据库事务。\n\n\n\n此方法接收两个参数：\n\n 1. 数组：填写需要操作的表的名字（[table1, table2, ...]）\n 2. 操作类型：readonly(只读) or readwrite(读写)\n\n> 返回一个事务对象，该对象的 objectStore 方法用于获取指定的表(只能在你创建事物时传入的数组中选取)。\n\n\n\n返回的事务对象中有 3 个事件\n\n * abort: 事务中断\n * complete: 事务完成\n * error: 事务出错\n\n\n\n返回的 objectStore 对象有以下方法，用于操作数据。\n\n 1. add — 添加数据\n\n> add 方法是异步的，有自己的 success and error 事件\n\n\n\n 2. get — 读取数据\n\n> get 方法是异步的，有自己的 success and error 事件\n\n\n\n> 从创建事务到读取数据，所有操作方法也可以写成下面这样链式形式。\n\n\n\n 3. put — 更新数据\n\n> 用法同 add 相似，异步\n\n\n\n 4. delete — 删除数据\n\n> 用法同 get 相似, 异步\n\n\n\n到此为止，整个数据库的创建以及基本使用已经会了。 你可以自行尝试去创建或使用一下。\n\n\n高级用法#\n\n\nIndex#\n\n要根据其他对象字段进行搜索，我们需要创建一个名为“索引（index）”的附加数据结构。\n\n> objectStore.createIndex(name, keyPath, [options]);\n\n * name — 索引名称\n * keyPath — 索引应该跟踪的对象字段的路径（我们将根据该字段进行搜索）。\n * option：\n   * unique — 如果为true，则存储中只有一个对象在 keyPath 上具有给定值。\n   * multiEntry — 只有 keypath 上的值是数组时才使用。\n\n在这之前的实例中，我们是通过默认创建表的时候给的 keyPath 来查询的 假设我们想通过 age 年龄来进行搜索\n\n\n\n * 该索引将跟踪 age 字段。\n * 年龄不是唯一的，可能有很多人年龄相同，所以我们不设置唯一 unique 选项。\n * 年龄不是一个数组，因此不适用多入口 multiEntry 标志。\n\n基于 index 获取数据#\n\n\n\n基于 index 删除数据#\n\n\n\n\n光标(Cursors)#\n\n\nAPI 总览#\n\n\nIDBDatabase#\n\n * name — 数据库名称\n * objectStoreNames — 当前数据库下所有 表的名称 string[]\n * version — 当前数据库的版本\n * close() — 关闭当前数据库连接\n * createObjectStore() —— 创建表\n\n> (name: string, options?: { keyPath?: string; autoIncrement?: boolean; }) =>\n> IDBObjectStore\n\n * deleteObjectStore() — 删除表\n\n> (name: string) => void\n\n * transaction()\n * close\n * versionchange\n\n\nIDBTransaction#\n\n * db — 当前事务的数据库对象(IDBDatabase)\n * durability\n * error — 错误事务类型\n * mode — 事务的操作模式 readonly or readwrite\n * objectStoreNames — 当前事务下操作的表的名称 string[]\n * abort()\n * commit()\n * objectStore()\n * abort\n * complete\n * error\n\n\nIDBObjectStore#\n\n * autoIncrement — 是否 自增\n * indexNames — indexes 名称列表\n * keyPath — 当前 objectStore 索引\n * name\n * transaction\n * add() — 添加数据\n\n> (obj: any, key?: any) => IDBRequest\n\n * clear() — 清除全部数据\n\n> () => IDBRequest\n\n * count()\n * createIndex() — 创建 index\n\n> (name: string, keyPath: string, options?: { unique?: boolean; multiEntry?:\n> boolean; }) => IDBIndex\n\n * delete() — 删除数据\n\n> (key: any) => IDBRequest\n\n * deleteIndex() — 删除 index\n\n> (indexName: string) => void\n\n * get() — 查询数据\n\n> (key: any) => IDBRequest\n\n * getAll() — 查询全部数据\n\n> () => IDBRequest\n\n * put() — 更新数据\n\n> put(obj: any, key?: any) => IDBRequest\n\n * getAllKeys()\n * getKey()\n * index()\n * openCursor()\n * openKeyCursor()\n\n\nIDBRequest#\n\n * error — 请求失败\n * readyState — 请求状态\n * result — 请求结果\n * source — 请求来源\n * transaction — 请求到事务\n\n可监听事件:\n\n * error — 请求失败\n * success — 请求成功\n\n\nIDBIndex#\n\n * keyPath — 当前 index 索引\n * multiEntry\n * name — 当前 index 的 name\n * objectStore — 当前 index 的 objectStore\n * unique — 当前索引是否唯一\n * count()\n * get() — 返回以当前 index索引为 keyPath 的值\n\n> (key?: any) => IDBRequest\n\n * getAll()\n * getAllKeys()\n * getKey()\n * openCursor()\n * openKeyCursor()\n\n\nIDBCursor#\n\n * direction\n\n * key\n\n * primaryKey\n\n * request\n\n * source\n\n * advance()\n\n * continue()\n\n * continuePrimaryKey()\n\n * delete()\n\n * update()\n\n\nDexie.js#\n\n> 对 indexedDB 封装的一个库，能够让我们向 jquery 一样链式调用，省去了维护各种异步事件操作的时间。支持\n> TypeScript、React、Angular、Svelte\n> \n> 以 React 为例操作一遍\n\n\n创建#\n\n> 这里创建了一个名叫 mydb 的数据库，版本为 1，里面有一个表 fristTable，表内容规定为一个有 id，name，age 三个属性的对象，且 id\n> 自增\n\n\n\n> 如果使用的是 typescript 需要类型支持可以这样写\n\n\n\n\n添加数据#\n\n> 因为上面定义表的时候使用的是自增的 id 所以你可以不需要传入 id，按照整数自增下去，该与表中 key 一一对应 也可以传递\n> id，会做对比，如果当前表中没有该 id,那么添加成功，否则添加失败\n\n\n\n\n查询数据#\n\n> 查询 id 为 key 的数据\n\n\n\n\n筛选数据#\n\n> 筛选出 10 <= id < 20 区间的所有数据\n\n\n\n更多使用自行查看官网","routePath":"/Explorers-Notes/frontEnd/javascript/IndexedDB","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"背景","id":"背景","depth":3,"charIndex":9},{"text":"特点:","id":"特点","depth":3,"charIndex":263},{"text":"基本流程","id":"基本流程","depth":2,"charIndex":1024},{"text":"前置","id":"前置","depth":3,"charIndex":1032},{"text":"连接数据库","id":"连接数据库","depth":3,"charIndex":1215},{"text":"创建数据表","id":"创建数据表","depth":3,"charIndex":1766},{"text":"数据库事务","id":"数据库事务","depth":3,"charIndex":1986},{"text":"高级用法","id":"高级用法","depth":2,"charIndex":2590},{"text":"Index","id":"index","depth":3,"charIndex":2598},{"text":"基于 index 获取数据","id":"基于-index-获取数据","depth":4,"charIndex":3025},{"text":"基于 index 删除数据","id":"基于-index-删除数据","depth":4,"charIndex":3043},{"text":"光标(Cursors)","id":"光标cursors","depth":3,"charIndex":3062},{"text":"API 总览","id":"api-总览","depth":2,"charIndex":3077},{"text":"IDBDatabase","id":"idbdatabase","depth":3,"charIndex":3087},{"text":"IDBTransaction","id":"idbtransaction","depth":3,"charIndex":3435},{"text":"IDBObjectStore","id":"idbobjectstore","depth":3,"charIndex":3672},{"text":"IDBRequest","id":"idbrequest","depth":3,"charIndex":4368},{"text":"IDBIndex","id":"idbindex","depth":3,"charIndex":4520},{"text":"IDBCursor","id":"idbcursor","depth":3,"charIndex":4812},{"text":"Dexie.js","id":"dexiejs","depth":2,"charIndex":4965},{"text":"创建","id":"创建","depth":3,"charIndex":5094},{"text":"添加数据","id":"添加数据","depth":3,"charIndex":5224},{"text":"查询数据","id":"查询数据","depth":3,"charIndex":5338},{"text":"筛选数据","id":"筛选数据","depth":3,"charIndex":5367}],"domain":"","frontmatter":{"title":"IndexedDB 数据库","date":"2023-08-21T16:46:09.000Z"},"version":""},{"id":8,"title":"JavaScript 观察者 API","content":"#\n\n在现代 Web 开发中，观察者模式是一种非常重要的设计模式，它允许我们监听和响应对象的变化。JavaScript 提供了几种强大的观察者\nAPI，使得我们能够轻松地处理 DOM 变化、视口变化、元素尺寸变化等各种动态场景。本文将介绍四种常见的观察者\nAPI：MutationObserver、IntersectionObserver、ResizeObserver 和 PerformanceObserver。\n\n\n1. MutationObserver：监听 DOM 变动#\n\n\n1.1 什么是 MutationObserver？#\n\nMutationObserver 是一个用于观察 DOM 树变化的 API。当 DOM\n中的元素发生变化时（如添加、删除子节点或更改属性等），MutationObserver 可以发出通知。这在某些场景下非常有用，例如，当我们想要在某些 DOM\n元素变化时自动触发某些操作时。\n\n\n1.2 典型用法#\n\n我们可以创建一个 MutationObserver 实例，并通过指定配置来监听特定的 DOM 变化。以下是一个基本示例：\n\n\n\n\n1.3 常见用途#\n\n * 监听 DOM 结构的动态变化\n * 监听元素属性的变化，如 class、style 等\n * 适用于处理由 JavaScript 动态生成的内容\n\n\n2. IntersectionObserver：监听元素与视口交集#\n\n\n2.1 什么是 IntersectionObserver？#\n\nIntersectionObserver\n用于监听元素与视口（或其他元素）的交叉情况。它常用于实现懒加载、无限滚动等功能，能够在元素进入或离开视口时触发回调函数，从而做出响应。\n\n\n2.2 典型用法#\n\n我们可以使用 IntersectionObserver 来监听某个元素是否进入视口，并执行相应的操作。例如：\n\n\n\n\n2.3 常见用途#\n\n * 实现懒加载：当图片或其他内容进入视口时才加载\n * 无限滚动：当页面滚动到底部时，加载更多内容\n * 实现可视区域检测：例如，判断广告元素是否完全进入视口\n\n\n3. ResizeObserver：监听元素尺寸变化#\n\n\n3.1 什么是 ResizeObserver？#\n\nResizeObserver 允许我们监听元素的尺寸变化，它能够在元素大小发生变化时触发回调，常用于响应式设计中，帮助我们在窗口或元素大小改变时进行调整。\n\n\n3.2 典型用法#\n\n我们可以通过 ResizeObserver 来监控元素尺寸的变化，并根据变化调整布局或执行其他操作：\n\n\n\n\n3.3 常见用途#\n\n * 响应式设计：根据元素的尺寸变化调整布局\n * 动态调整元素位置或大小：例如，调整视频播放器的大小\n * 监控布局变化，确保 UI 元素始终在正确的位置\n\n\n4. PerformanceObserver：监听性能相关事件#\n\n\n4.1 什么是 PerformanceObserver？#\n\nPerformanceObserver 是用于监控性能相关事件的 API。它可以监听浏览器的性能信息，如资源加载、页面渲染时间等。该 API\n主要用于性能分析和优化。\n\n\n4.2 典型用法#\n\n我们可以使用 PerformanceObserver 来监听性能相关的条目，例如资源加载、页面加载等：\n\n\n\n\n4.3 常见用途#\n\n * 页面加载性能分析：监控页面加载时间、资源加载时间\n * 优化页面渲染：分析关键渲染指标，如 first-contentful-paint (FCP)\n * 资源加载优化：监控图片、脚本等静态资源的加载情况\n\n\n5. 总结#\n\nJavaScript 中的观察者 API 提供了灵活、性能高效的方式来监听 DOM 变化、元素交集、尺寸变化和性能数据。使用这些\nAPI，可以帮助我们构建更具响应性和高效的 Web 应用。\n\n * MutationObserver 用于监听 DOM 结构的变化\n * IntersectionObserver 用于监听元素与视口的交集\n * ResizeObserver 用于监听元素尺寸的变化\n * PerformanceObserver 用于监听性能相关的事件\n\n这些 API 的使用可以提升应用性能，减少不必要的资源消耗，并增强用户体验。掌握这些工具，将帮助开发者更好地处理动态内容和性能问题。","routePath":"/Explorers-Notes/frontEnd/javascript/observer","lang":"","toc":[{"text":"1. **MutationObserver：监听 DOM 变动**","id":"1-mutationobserver监听-dom-变动","depth":2,"charIndex":-1},{"text":"1.1 什么是 `MutationObserver`？","id":"11-什么是-mutationobserver","depth":3,"charIndex":-1},{"text":"1.2 典型用法","id":"12-典型用法","depth":3,"charIndex":411},{"text":"1.3 常见用途","id":"13-常见用途","depth":3,"charIndex":487},{"text":"2. **IntersectionObserver：监听元素与视口交集**","id":"2-intersectionobserver监听元素与视口交集","depth":2,"charIndex":-1},{"text":"2.1 什么是 `IntersectionObserver`？","id":"21-什么是-intersectionobserver","depth":3,"charIndex":-1},{"text":"2.2 典型用法","id":"22-典型用法","depth":3,"charIndex":736},{"text":"2.3 常见用途","id":"23-常见用途","depth":3,"charIndex":806},{"text":"3. **ResizeObserver：监听元素尺寸变化**","id":"3-resizeobserver监听元素尺寸变化","depth":2,"charIndex":-1},{"text":"3.1 什么是 `ResizeObserver`？","id":"31-什么是-resizeobserver","depth":3,"charIndex":-1},{"text":"3.2 典型用法","id":"32-典型用法","depth":3,"charIndex":1036},{"text":"3.3 常见用途","id":"33-常见用途","depth":3,"charIndex":1102},{"text":"4. **PerformanceObserver：监听性能相关事件**","id":"4-performanceobserver监听性能相关事件","depth":2,"charIndex":-1},{"text":"4.1 什么是 `PerformanceObserver`？","id":"41-什么是-performanceobserver","depth":3,"charIndex":-1},{"text":"4.2 典型用法","id":"42-典型用法","depth":3,"charIndex":1346},{"text":"4.3 常见用途","id":"43-常见用途","depth":3,"charIndex":1413},{"text":"5. **总结**","id":"5-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"JavaScript 观察者 API","date":"2024-12-27T16:00:00.000Z"},"version":""},{"id":9,"title":"Sass 基础","content":"#\n\n\n一、注释#\n\n>  1. Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。\n> \n>  2. 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n> \n>  3. 插值语句 (interpolation) 也可写进多行注释中输出变量值\n\n\n二、变量#\n\n\n1.定义#\n\n> 变量以美元符号开头，赋值方法与 CSS 属性的写法一样\n\n\n\n\n2.使用#\n\n> 直接使用变量的名称即可调用变量\n\n\n\n\n3.作用域#\n\n> 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可\n> 以添加 !global 声明\n\n\n\n编译后：\n\n\n\n--------------------------------------------------------------------------------\n\n\n三、数据类型#\n\n> SassScript 支持 7 种主要的数据类型：\n> \n>  * 数字，1, 2, 13, 10px\n>  * 字符串，有引号字符串与无引号字符串，\"foo\", 'bar', baz\n>  * 颜色，blue, #04a3f9, rgba(255,0,0,0.5)\n>  * 布尔型，true, false\n>  * 空值，null\n>  * 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif\n>  * maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)\n> \n> SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而 Sass\n> 不会特殊对待这些属性值，一律视为无引号字符串。\n> \n> 判断数据类型的方式：type-of($value)\n\n\n1.字符串 (Strings)#\n\n> SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，和无引号字符串 (unquoted strings)。\n\n\n\n\n2.数字(Numbers)#\n\n> SassScript 支持两种数字类型：带单位数字和不带单位数字。（可正可负可为零，可正可浮点）\n\n\n\n\n3.空值(Null)#\n\n> 只有一个取值null\n\n\n\n\n4.布尔型(Booleans)#\n\n> 只有两个取值：true和false\n\n\n\n\n5.数组 (Lists)#\n\n> 通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从1开始\n\n\n\n> 数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px\n> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px\n> 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px)\n> 则使用空格分割(space-separated)。\n> \n> 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px,\n> 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n> \n> 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family:\n> () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。\n> \n> 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1\n> 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。\n\n\n6.映射(Maps)#\n\n> Maps 必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌 maps，不过不推荐这种内嵌方式）\n\n\n\n\n7.颜色 (Colors)#\n\n> CSS 原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA 和色彩单词\n> \n> SCSS 提供了内置 Colors 函数，从而更方便地使用颜色\n\n\n\n--------------------------------------------------------------------------------\n\n\n四、运算#\n\n\n1.数字运算符#\n\n> SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值\n> \n> 如果要保留运算符号，则应该使用插值语法\n\n * +\n   \n   \n   \n   \n\n * -\n   \n   \n   \n   \n\n * *\n   \n   \n   \n   \n\n * /\n   \n   \n\n * %\n   \n   \n\n\n2.关系运算符#\n\n> 大前提：两端必须为数字 或 前部分数字后部分字符\n> \n> 返回值：true or false\n\n * >\n   \n   \n\n * <\n   \n   \n\n * >=\n   \n   \n\n * <=\n   \n   \n\n\n3.相等运算符#\n\n> 作用范围：相等运算 ==, != 可用于所有数据类型\n> \n> 返回值：true or false\n\n\n\n\n\n\n4.布尔运算符#\n\n> SassScript 支持布尔型的 and or 以及 not 运算。\n\n\n\n\n5.颜色值运算#\n\n> 颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值\n\n * 颜色值与颜色值\n   \n   \n\n * 颜色值与数字\n   \n   \n\n * RGB和HSL\n   \n   \n\n\n6.运算优先级#\n\n 0. ()\n\n 1. *、/、%\n\n 2. +、-\n\n 3. > 、<、>=、<=\n\n--------------------------------------------------------------------------------\n\n\n五、嵌套语法#\n\n> 此部分过于简单不计入笔记\n\n--------------------------------------------------------------------------------\n\n\n六、杂货语法#\n\n\n1.插值语法#\n\n通过 #{} 插值语句可以在选择器、属性名和属性值中使用变量。\n\n但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。\n\n\n\n\n2.& in SassScript#\n\n&为父选择器\n\n\n\n\n3.!default#\n\n可以在变量的结尾添加 !default 给一个未通过 !default\n声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n\n\n\n注意：变量是 null 空值时将视为未被 !default 赋值。\n\n\n3.!global#\n\n将局部变量提升为全局变量\n\n\n4.!optional#\n\n如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice\n选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。\n\n如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的.\n\n简而言之：当@extend相关代码出现语法错误时，编译器可能会给我们\"乱\"编译为 css，我们加上这个参数可以在出现问题后不让他编译该部分代码\n\n--------------------------------------------------------------------------------\n\n\n七、@-Rules 与指令#\n\n\n1.@import#\n\n> Sass 拓展了 @import 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS\n> 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\n> \n> 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n> \n>  * 文件拓展名是 .css；\n>  * 文件名以 http:// 开头；\n>  * 文件名是 url()；\n>  * @import 包含 media queries。\n> \n> 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或\n> .sass 的文件并将其导入。\n\n\n\n> Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n\n\n\n> 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：\n\n\n\n> 如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。\n> 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。\n> \n> 除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。\n\n\n2.@media#\n\n> Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS\n> 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS\n> 的书写流程。\n\n\n\n> @media的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and\n\n\n\n> @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值\n\n\n\n\n3.@extend#\n\n> @extend即继承。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。\n\n--------------------------------------------------------------------------------\n\n\n八、控制指令#\n\n\n1.if()#\n\n三元运算符\n\n表达式：if(expression, value1, value2)\n\n\n\n\n2.@if#\n\n条件语句\n\n当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码\n\n@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if\n声明，如果全部失败，最后执行 @else 声明\n\n * 单@if\n   \n   \n\n * @if - @else\n   \n   \n\n * @if - @else if - @else\n   \n   \n\n\n3.@for#\n\n循环语句\n\n表达式：@for $var from through 或 @for $var from to\n\nthrough 和 to 的相同点与不同点：\n\n * 相同点：两者均包含的值\n * 不同点：through 包含的值，但 to 不包含的值\n\n\n\n\n4.@while#\n\n循环语句\n\n表达式：@while expression\n\n@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到\n\n\n\n\n5.@each#\n\n循环语句\n\n表达式：$var in $vars\n\n\n\n--------------------------------------------------------------------------------\n\n\n九、混合指令#\n\n> 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分\n> Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n\n注意：这不是函数！没有返回值！！\n\n\n1.定义混合指令#\n\n混合指令的用法是在 @mixin 后添加名称与样式，以及需要的参数（可选）。\n\n\n\n\n\n\n2.引用混合样式#\n\n使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。\n\n\n\n\n\n\n3.参数#\n\n格式：按照变量的格式，通过逗号分隔，将参数写进 Mixin 名称后的圆括号里\n\n支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参\n\na. 位置传参#\n\n\n\nb.关键词传参#\n\n\n\nc.参数默认值#\n\n\n\nd.不定参数#\n\n> 官方：Variable Arguments\n> \n> 译文：参数变量\n> \n> 有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理\n\n\n\n\n4.向混合样式中导入内容#\n\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方（ 少用，逻辑容易混乱 ）\n\n\n\n--------------------------------------------------------------------------------\n\n\n十、函数指令#\n\n\n1.内置函数#\n\na. 字符串函数#\n\n> 索引第一个为 1，最后一个为-1；切片两边均为闭区间\n\n函数名和参数类型                                 函数作用\nquote($string)                           添加引号\nunquote($string)                         除去引号\nto-lower-case($string)                   变为小写\nto-upper-case($string)                   变为大写\nstr-length($string)                      返回$string 的长度(汉字算一个)\nstr-index($string，$substring)            返回$substring在$string 的位置\nstr-insert($string, $insert, $index)     在$string的$index 处插入$insert\nstr-slice($string, $start-at, $end-at）   截取$string的$start-at 和$end-at 之间的字符串\n\nb. 数字函数#\n\n函数名和参数类型                  函数作用\npercentage($number)       转换为百分比形式\nround($number)            四舍五入为整数\nceil($number)             数值向上取整\nfloor($number)            数值向下取整\nabs($number)              获取绝对值\nmin($number...)           获取最小值\nmax($number...)           获取最大值\nrandom($number?:number)   不传入值：获得 0-1 的随机数；传入正整数 n：获得 0-n 的随机整数（左开右闭）\n\nc. 数组函数#\n\n函数名和参数类型                           函数作用\nlength($list)                      获取数组长度\nnth($list, n)                      获取指定下标的元素\nset-nth($list, $n, $value)         向$list的$n 处插入$value\njoin($list1, $list2, $separator)   拼接$list1和list2；$separator 为新 list 的分隔符，默认为 auto，可选择\n                                   comma、space\nappend($list, $val, $separator)    向$list的末尾添加$val；$separator 为新 list 的分隔符，默认为 auto，可选择\n                                   comma、space\nindex($list, $value)               返回$value值在$list 中的索引值\nzip($lists…)                       将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的\n\nd. 映射函数#\n\n函数名和参数类型                  函数作用\nmap-get($map, $key)       获取$map中$key 对应的$value\nmap-merge($map1, $map2)   合并$map1和$map2，返回一个新$map\nmap-remove($map, $key)    从$map中删除$key，返回一个新$map\nmap-keys($map)            返回$map所有的$key\nmap-values($map)          返回$map所有的$value\nmap-has-key($map, $key)   判断$map中是否存在$key，返回对应的布尔值\nkeywords($args)           返回一个函数的参数，并可以动态修改其值\n\ne. 颜色函数#\n\n * RGB 函数\n   \n   函数名和参数类型                         函数作用\n   rgb($red, $green, $blue)         返回一个 16 进制颜色值\n   rgba($red,$green,$blue,$alpha)   返回一个 rgba；$red,$green 和$blue 可被当作一个整体以颜色单词、hsl、rgb 或 16\n                                    进制形式传入\n   red($color)                      从$color 中获取其中红色值\n   green($color)                    从$color 中获取其中绿色值\n   blue($color)                     从$color 中获取其中蓝色值\n   mix($color1,$color2,$weight?)    按照$weight比例，将$color1 和$color2 混合为一个新颜色\n\n * HSL 函数\n   \n   函数名和参数类型                                   函数作用\n   hsl($hue,$saturation,$lightness)           通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色\n   hsla($hue,$saturation,$lightness,$alpha)   通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色\n   saturation($color)                         从一个颜色中获取饱和度（saturation）值\n   lightness($color)                          从一个颜色中获取亮度（lightness）值\n   adjust-hue($color,$degrees)                通过改变一个颜色的色相值，创建一个新的颜色\n   lighten($color,$amount)                    通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色\n   darken($color,$amount)                     通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色\n   hue($color)                                从一个颜色中获取亮度色相（hue）值\n\n * Opacity 函数\n   \n                                                                 \n   alpha($color)/opacity($color)                                 获取颜色透明度值\n   rgba($color,$alpha)                                           改变颜色的透明度\n   opacify($color, $amount) / fade-in($color, $amount)           使颜色更不透明\n   transparentize($color, $amount) / fade-out($color, $amount)   使颜色更加透明\n\nf. Introspection 函数#\n\n函数名和参数类型                         函数作用\ntype-of($value)                  返回$value 的类型\nunit($number)                    返回$number 的单位\nunitless($number)                判断$number 是否带单位，返回对应的布尔值\ncomparable($number1, $number2)   判断$number1和$number2 是否可以做加、减和合并，返回对应的布尔值\n\n\n2.自定义函数#\n\n> Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用\n> \n> Params: 与 Mixin 一致\n> \n> 支持返回值\n\n基本格式：\n\n\n\n","routePath":"/Explorers-Notes/frontEnd/sass/base","lang":"","toc":[{"text":"一、注释","id":"一注释","depth":2,"charIndex":3},{"text":"二、变量","id":"二变量","depth":2,"charIndex":195},{"text":"1.定义","id":"1定义","depth":3,"charIndex":203},{"text":"2.使用","id":"2使用","depth":3,"charIndex":244},{"text":"3.作用域","id":"3作用域","depth":3,"charIndex":273},{"text":"三、数据类型","id":"三数据类型","depth":2,"charIndex":473},{"text":"1.字符串 (Strings)","id":"1字符串-strings","depth":3,"charIndex":916},{"text":"2.数字(Numbers)","id":"2数字numbers","depth":3,"charIndex":1019},{"text":"3.空值(Null)","id":"3空值null","depth":3,"charIndex":1090},{"text":"4.布尔型(Booleans)","id":"4布尔型booleans","depth":3,"charIndex":1120},{"text":"5.数组 (Lists)","id":"5数组-lists","depth":3,"charIndex":1162},{"text":"6.映射(Maps)","id":"6映射maps","depth":3,"charIndex":1901},{"text":"7.颜色 (Colors)","id":"7颜色-colors","depth":3,"charIndex":1974},{"text":"四、运算","id":"四运算","depth":2,"charIndex":2155},{"text":"1.数字运算符","id":"1数字运算符","depth":3,"charIndex":2163},{"text":"2.关系运算符","id":"2关系运算符","depth":3,"charIndex":2354},{"text":"3.相等运算符","id":"3相等运算符","depth":3,"charIndex":2474},{"text":"4.布尔运算符","id":"4布尔运算符","depth":3,"charIndex":2542},{"text":"5.颜色值运算","id":"5颜色值运算","depth":3,"charIndex":2594},{"text":"6.运算优先级","id":"6运算优先级","depth":3,"charIndex":2702},{"text":"五、嵌套语法","id":"五嵌套语法","depth":2,"charIndex":2839},{"text":"六、杂货语法","id":"六杂货语法","depth":2,"charIndex":2947},{"text":"1.`插值语法`","id":"1插值语法","depth":3,"charIndex":-1},{"text":"2.`& in SassScript`","id":"2-in-sassscript","depth":3,"charIndex":-1},{"text":"3.`!default`","id":"3default","depth":3,"charIndex":-1},{"text":"3.`!global`","id":"3global","depth":3,"charIndex":-1},{"text":"4.`!optional`","id":"4optional","depth":3,"charIndex":-1},{"text":"七、@-Rules 与指令","id":"七-rules-与指令","depth":2,"charIndex":3621},{"text":"1.`@import`","id":"1import","depth":3,"charIndex":-1},{"text":"2.`@media`","id":"2media","depth":3,"charIndex":-1},{"text":"3.`@extend`","id":"3extend","depth":3,"charIndex":-1},{"text":"八、控制指令","id":"八控制指令","depth":2,"charIndex":4843},{"text":"1.`if()`","id":"1if","depth":3,"charIndex":-1},{"text":"2.`@if`","id":"2if","depth":3,"charIndex":-1},{"text":"3.`@for`","id":"3for","depth":3,"charIndex":-1},{"text":"4.`@while`","id":"4while","depth":3,"charIndex":-1},{"text":"5.`@each`","id":"5each","depth":3,"charIndex":-1},{"text":"九、混合指令","id":"九混合指令","depth":2,"charIndex":5506},{"text":"1.定义混合指令","id":"1定义混合指令","depth":3,"charIndex":5649},{"text":"2.引用混合样式","id":"2引用混合样式","depth":3,"charIndex":5705},{"text":"3.参数","id":"3参数","depth":3,"charIndex":5769},{"text":"a. 位置传参","id":"a-位置传参","depth":4,"charIndex":5849},{"text":"b.关键词传参","id":"b关键词传参","depth":4,"charIndex":5861},{"text":"c.参数默认值","id":"c参数默认值","depth":4,"charIndex":5873},{"text":"d.不定参数","id":"d不定参数","depth":4,"charIndex":5885},{"text":"4.向混合样式中导入内容","id":"4向混合样式中导入内容","depth":3,"charIndex":6008},{"text":"十、函数指令","id":"十函数指令","depth":2,"charIndex":6187},{"text":"1.内置函数","id":"1内置函数","depth":3,"charIndex":6197},{"text":"a. 字符串函数","id":"a-字符串函数","depth":4,"charIndex":6206},{"text":"b. 数字函数","id":"b-数字函数","depth":4,"charIndex":6751},{"text":"c. 数组函数","id":"c-数组函数","depth":4,"charIndex":7094},{"text":"d. 映射函数","id":"d-映射函数","depth":4,"charIndex":7681},{"text":"e. 颜色函数","id":"e-颜色函数","depth":4,"charIndex":8049},{"text":"f. Introspection 函数","id":"f-introspection-函数","depth":4,"charIndex":9594},{"text":"2.自定义函数","id":"2自定义函数","depth":3,"charIndex":9881}],"domain":"","frontmatter":{"title":"Sass 基础","date":"2022-03-16T08:00:47.000Z"},"version":""},{"id":10,"title":"TypeScript 基础","content":"> 阮一峰更新了 TypeScript 的教程，内容更全易懂\n\n\nTypeScript 基础#\n\n\n一、数据类型。#\n\n\n1、布尔值#\n\n布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：\n\n\n\n\n2、数值#\n\n使用 number 定义数值类型：\n\n\n\n编译结果：\n\n\n\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。\n\n\n3、字符串#\n\n使用 string 定义字符串类型：\n\n\n\n编译结果：\n\n\n\n其中 ``` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。\n\n\n4、空值#\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：\n\n\n\n\n5、Null 和 Undefined#\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n\n\n\n6、任意值（ any ）#\n\n> 相当于是去掉了 Typescript 的类型强调，可以给赋任何值，也可以赋值给容易，在代码中尽量不用\n\n\n\n\n7、数组#\n\nⅠ、最简单的方法是使用「类型 + 方括号」来表示数组：#\n\n\n\n> 数组的项中不允许出现其他的类型：\n\n\n\n> 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n\n\n> 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 \"8\" 字符串类型的参数，所以报错了。\n\nⅡ、数组泛型#\n\n我们也可以使用数组泛型（Array Generic） Array 来表示数组：\n\n\n\n关于泛型，可以参考泛型一章。\n\nⅢ、用接口表示数组#\n\n接口也可以用来描述数组：\n\n\n\n> NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n> \n> 虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n> \n> 不过有一种情况例外，那就是它常用来表示类数组。\n\n\n二、类型推论#\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。\n\n\n1、什么是类型推论#\n\n> 以下代码虽然没有指定类型，但是会在编译的时候报错：\n\n\n\n> 事实上，它等价于：\n\n\n\n> TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n> \n> 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\n\n\n\n三、联合类型#\n\n> 联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n\n1、简单的例子#\n\n\n\n联合类型使用 | 分隔每个类型。\n\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string\n或者 number，但是不能是其他类型。\n\n\n四、函数的类型#\n\n\n1、函数声明#\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n\n\n注意，输入多余的（或者少于要求的）参数，是不被允许的：\n\n\n2、函数表达式#\n\n如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：\n\n\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的\nmySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：\n\n\n\n注意不要混淆了 TypeScript 中的 => 和 ES6 中的 =>。\n\n在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，=> 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。\n\n\n3、用接口定义函数的形状#\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n4、可选参数#\n\n前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\n\n\n\n\n5、参数默认值#\n\n在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：\n\n\n\n> 关于默认参数，可以参考 ES6 中函数参数的默认值。\n\n\n五、类型别名type#\n\n类型别名用来给一个类型起个新名字。\n\n\n简单的例子#\n\n\n\n上例中，我们使用 type 创建类型别名。\n\n类型别名常用于联合类型。\n\n\n六、类型断言#\n\n类型断言（Type Assertion）可以用来手动指定一个值的类型。\n\n\n1、语法#\n\n\n\n或\n\n\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n\n形如 的语法在 tsx 中表示的是一个 ReactNode，在 ts 中除了表示类型断言之外，也可能是表示一个泛型。\n\n故建议大家在使用类型断言时，统一使用 值 as 类型 这样的语法。\n\n\n2、类型断言的用途#\n\n> 将一个联合类型断言为其中一个类型\n\n之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：\n\n\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\n\n\n\n上面的例子中，获取 animal.swim 的时候会报错。\n\n此时可以使用类型断言，将 animal 断言成 Fish：\n\n\n\n这样就可以解决访问 animal.swim 时报错的问题了。\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n\n\n\n上面的例子编译时不会报错，但在运行时会报错：\n\n\n\n原因是 (animal as Fish).swim() 这段代码隐藏了 animal 可能为 Cat 的情况，将 animal 直接断言为 Fish 了，而\nTypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误。\n\n可是 swim 函数接受的参数是 Cat | Fish，一旦传入的参数是 Cat 类型的变量，由于 Cat 上没有 swim 方法，就会导致运行时错误了。\n\n总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。\n\n\n3、双重断言#\n\n既然：\n\n * 任何类型都可以被断言为 any\n * any 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？\n\n\n\n在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n**除非迫不得已，千万别用双重断言。**\n\n\n4、类型断言 => 类型转换 ?#\n\n类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n\n\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\n\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\n\n\n\n七、元组#\n\n> 数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n> \n> 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。\n\n\n简单的例子#\n\n定义一对值分别为 string 和 number 的元组：\n\n\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\n\n\n\n也可以只赋值其中一项：\n\n\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\n\n\n\n\n越界的元素#\n\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\n\n\n\n\n八、枚举enum#\n\n> 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n\n\n简单的例子#\n\n枚举使用 enum 关键字来定义：\n\n\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：\n\n\n\n事实上，上面的例子会被编译为：\n\n\n\n\n手动赋值#\n\n我们也可以给枚举项手动赋值：\n\n\n\n上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。\n\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：\n\n\n\n上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 \"Sun\"，而后又被\n\"Wed\" 覆盖了。编译的结果是：\n\n\n\n所以使用的时候需要注意，最好不要出现这种覆盖的情况。\n\n手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：\n\n\n\n当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：\n\n\n\n\n常数项和计算所得项#\n\n枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。\n\n前面我们所举的例子都是常数项，一个典型的计算所得项的例子：\n\n\n\n上面的例子中，\"blue\".length 就是一个计算所得项。\n\n上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：\n\n\n\n下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举：\n\n当满足以下条件时，枚举成员被当作是常数：\n\n * 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加\n   1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。\n * 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript\n   表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n   * 数字字面量\n   * 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用\n   * 带括号的常数枚举表达式\n   * +, -, ~ 一元运算符应用于常数枚举表达式\n   * +, -, *, /, %, <<, >>, >>>, &, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN\n     或 Infinity，则会在编译阶段报错\n\n所有其它情况的枚举成员被当作是需要计算得出的值。\n\n\n常数枚举#\n\n常数枚举是使用 const enum 定义的枚举类型：\n\n\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n\n上例的编译结果是：\n\n\n\n假如包含了计算成员，则会在编译阶段报错：\n\n\n\n\n外部枚举§#\n\n外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型：\n\n\n\n之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n上例的编译结果是：\n\n\n\n外部枚举与声明语句一样，常出现在声明文件中。\n\n同时使用 declare 和 const 也是可以的：\n\n\n\n编译结果：\n\n\n\n> TypeScript 的枚举类型的概念来源于 C#。\n\n\n九、接口#\n\n> 在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n\n1、什么是接口#\n\n> 在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n> \n> TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述\n\n\n2、简单的例子#\n\n\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person\n一致。\n\n\n3、可选属性#\n\n> 有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n\n\n> 可选属性的含义是该属性可以不存在。\n\n\n4、任意属性#\n\n> 有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n\n\n> 使用 [propName: string] 定义了任意属性取 string 类型的值。\n\n\n5、只读属性#\n\n> 有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\n\n> 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n\n十、类#\n\nTypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。\n\n * public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n * private 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n * protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n下面举一些例子：\n\n\n\n上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。\n\n很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：\n\n\n\n需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。\n\n上面的例子编译后的代码是：\n\n\n\n使用 private 修饰的属性或方法，在子类中也是不允许访问的：\n\n\n\n而如果是用 protected 修饰，则允许在子类中访问：\n\n\n\n当构造函数修饰为 private 时，该类不允许被继承或者实例化：\n\n\n\n当构造函数修饰为 protected 时，该类只允许被继承：\n\n\n\n\n参数属性#\n\n修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\n\n\n\n\nreadonly#\n\n只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\n\n\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\n\n\n\n\n抽象类#\n\nabstract 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\n\n\n上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\n\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\n\n\n上面的例子中，我们实现了抽象方法 sayHi，编译通过了。\n\n需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：\n\n\n\n\n类的类型#\n\n给类加上 TypeScript 的类型很简单，与接口类似：\n\n\n\n\n十一、类与接口#\n\n接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。\n\n这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。\n\n\n类实现接口#\n\n实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（\ninterfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以\n考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\n\n\n\n一个类可以实现多个接口：\n\n\n\n上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。\n\n\n接口继承接口#\n\n接口与接口之间可以是继承关系：\n\n\n\n这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。\n\n\n接口继承类#\n\n常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：\n\n\n\n为什么 TypeScript 会支持接口继承类呢？\n\n实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。\n\n所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例）：\n\n\n\n也可以将 Point 当做一个类型来用（使用 : Point 表示参数的类型）：\n\n\n\n这个例子实际上可以等价于：\n\n\n\n上例中我们新声明的 PointInstanceType 类型，与声明 class Point 时创建的 Point 类型是等价的。\n\n所以回到 Point3d 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：\n\n\n\n当我们声明 interface Point3d extends Point 时，Point3d 继承的实际上是类 Point 的实例的类型。\n\n换句话说，可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType。\n\n所以「接口继承类」和「接口继承接口」没有什么本质的区别。\n\n值得注意的是，PointInstanceType 相比于 Point，缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point\n类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。\n\n换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法：\n\n\n\n上例中最后的类型 Point 和类型 PointInstanceType 是等价的。\n\n同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。\n\n\n十二、泛型#\n\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n\n简单的例子#\n\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\n\n\n\n上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。\n\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\n\nArray 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n\n这时候，泛型就派上用场了：\n\n\n\n上例中，我们在函数名后添加了 ，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array 中即可使用了。\n\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\n\n\n\n\n多个类型参数#\n\n定义泛型的时候，可以一次定义多个类型参数：\n\n\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n\n\n泛型约束#\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\n\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\n\n\n\n上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\n\n\n\n多个类型参数之间也可以互相约束：\n\n\n\n上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。\n\n\n泛型接口#\n\n可以使用接口的方式来定义一个函数需要符合的形状：\n\n\n\n当然也可以使用含有泛型的接口来定义函数的形状：\n\n\n\n进一步，我们可以把泛型参数提前到接口名上：\n\n\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n\n\n泛型类#\n\n与泛型接口类似，泛型也可以用于类的类型定义中：\n\n\n\n\n泛型参数的默认类型#\n\n在 TypeScript 2.3\n以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\n\n\n\n十三、声明合并#\n\n如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：\n\n\n函数的合并#\n\n我们可以使用重载定义多个函数类型：\n\n\n\n\n接口的合并#\n\n接口中的属性在合并时会简单的合并到一个接口中：\n\n\n\n相当于：\n\n\n\n注意，合并的属性的类型必须是唯一的：\n\n\n\n接口中方法的合并，与函数的合并一样：\n\n\n\n相当于：\n\n\n\n\n类的合并#\n\n类的合并与接口的合并规则一致。","routePath":"/Explorers-Notes/frontEnd/typescript/base","lang":"","toc":[{"text":"一、数据类型。","id":"一数据类型","depth":2,"charIndex":49},{"text":"1、布尔值","id":"1布尔值","depth":3,"charIndex":60},{"text":"2、数值","id":"2数值","depth":3,"charIndex":120},{"text":"3、字符串","id":"3字符串","depth":3,"charIndex":210},{"text":"4、空值","id":"4空值","depth":3,"charIndex":299},{"text":"5、Null 和 Undefined","id":"5null-和-undefined","depth":3,"charIndex":426},{"text":"6、任意值（ any ）","id":"6任意值-any-","depth":3,"charIndex":502},{"text":"7、数组","id":"7数组","depth":3,"charIndex":574},{"text":"Ⅰ、最简单的方法是使用「类型 + 方括号」来表示数组：","id":"ⅰ最简单的方法是使用类型--方括号来表示数组","depth":4,"charIndex":581},{"text":"Ⅱ、数组泛型","id":"ⅱ数组泛型","depth":4,"charIndex":732},{"text":"Ⅲ、用接口表示数组","id":"ⅲ用接口表示数组","depth":4,"charIndex":800},{"text":"二、类型推论","id":"二类型推论","depth":2,"charIndex":950},{"text":"1、什么是类型推论","id":"1什么是类型推论","depth":3,"charIndex":1006},{"text":"三、联合类型","id":"三联合类型","depth":2,"charIndex":1163},{"text":"1、简单的例子","id":"1简单的例子","depth":3,"charIndex":1210},{"text":"四、函数的类型","id":"四函数的类型","depth":2,"charIndex":1342},{"text":"1、函数声明","id":"1函数声明","depth":3,"charIndex":1353},{"text":"2、函数表达式","id":"2函数表达式","depth":3,"charIndex":1457},{"text":"3、用接口定义函数的形状","id":"3用接口定义函数的形状","depth":3,"charIndex":1768},{"text":"4、可选参数","id":"4可选参数","depth":3,"charIndex":1881},{"text":"5、参数默认值","id":"5参数默认值","depth":3,"charIndex":1964},{"text":"五、类型别名`type`","id":"五类型别名type","depth":2,"charIndex":-1},{"text":"简单的例子","id":"简单的例子","depth":3,"charIndex":2096},{"text":"六、类型断言","id":"六类型断言","depth":2,"charIndex":2144},{"text":"1、语法","id":"1语法","depth":3,"charIndex":2191},{"text":"2、类型断言的用途","id":"2类型断言的用途","depth":3,"charIndex":2351},{"text":"3、双重断言","id":"3双重断言","depth":3,"charIndex":2946},{"text":"4、类型断言  =>  类型转换 ?","id":"4类型断言----类型转换-","depth":3,"charIndex":-1},{"text":"七、元组","id":"七元组","depth":2,"charIndex":3436},{"text":"简单的例子","id":"简单的例子-1","depth":3,"charIndex":3519},{"text":"越界的元素","id":"越界的元素","depth":3,"charIndex":3652},{"text":"八、枚举`enum`","id":"八枚举enum","depth":2,"charIndex":-1},{"text":"简单的例子","id":"简单的例子-2","depth":3,"charIndex":3760},{"text":"手动赋值","id":"手动赋值","depth":3,"charIndex":3853},{"text":"常数项和计算所得项","id":"常数项和计算所得项","depth":3,"charIndex":4190},{"text":"常数枚举","id":"常数枚举","depth":3,"charIndex":4878},{"text":"外部枚举§","id":"外部枚举","depth":3,"charIndex":4992},{"text":"九、接口","id":"九接口","depth":2,"charIndex":5198},{"text":"1、什么是接口","id":"1什么是接口","depth":3,"charIndex":5252},{"text":"2、简单的例子","id":"2简单的例子","depth":3,"charIndex":5419},{"text":"3、可选属性","id":"3可选属性","depth":3,"charIndex":5518},{"text":"4、任意属性","id":"4任意属性","depth":3,"charIndex":5582},{"text":"5、只读属性","id":"5只读属性","depth":3,"charIndex":5674},{"text":"十、类","id":"十类","depth":2,"charIndex":5785},{"text":"参数属性","id":"参数属性","depth":3,"charIndex":6308},{"text":"readonly","id":"readonly","depth":3,"charIndex":6372},{"text":"抽象类","id":"抽象类","depth":3,"charIndex":6459},{"text":"类的类型","id":"类的类型","depth":3,"charIndex":6775},{"text":"十一、类与接口","id":"十一类与接口","depth":2,"charIndex":6816},{"text":"类实现接口","id":"类实现接口","depth":3,"charIndex":6898},{"text":"接口继承接口","id":"接口继承接口","depth":3,"charIndex":7213},{"text":"接口继承类","id":"接口继承类","depth":3,"charIndex":7319},{"text":"十二、泛型","id":"十二泛型","depth":2,"charIndex":8144},{"text":"简单的例子","id":"简单的例子-3","depth":3,"charIndex":8212},{"text":"多个类型参数","id":"多个类型参数","depth":3,"charIndex":8551},{"text":"泛型约束","id":"泛型约束","depth":3,"charIndex":8618},{"text":"泛型接口","id":"泛型接口","depth":3,"charIndex":8973},{"text":"泛型类","id":"泛型类","depth":3,"charIndex":9089},{"text":"泛型参数的默认类型","id":"泛型参数的默认类型","depth":3,"charIndex":9123},{"text":"十三、声明合并","id":"十三声明合并","depth":2,"charIndex":9228},{"text":"函数的合并","id":"函数的合并","depth":3,"charIndex":9274},{"text":"接口的合并","id":"接口的合并","depth":3,"charIndex":9304},{"text":"类的合并","id":"类的合并","depth":3,"charIndex":9400}],"domain":"","frontmatter":{"title":"TypeScript 基础","date":"2022-06-07T12:37:52.000Z"},"version":""},{"id":11,"title":"TypeScript 装饰器","content":"#\n\n装饰器是 TypeScript\n提供的一个强大且灵活的元编程特性，允许开发者在运行时动态地修改类、方法、属性或参数的行为。在这篇文章中，我们将深入探讨装饰器的概念、使用场景及实际应用。\n\n\n1. 什么是装饰器？#\n\n装饰器是一个特殊的 TypeScript 元数据注解，它用于修改类、方法、属性或参数的行为。装饰器是基于 JavaScript 提案（目前为 Stage\n2）的实验性功能，在 TypeScript 中可通过启用 experimentalDecorators 编译选项来使用。\n\n\n装饰器的作用#\n\n装饰器允许你：\n\n * 修改类的行为或属性。\n * 为类的属性或方法添加元数据。\n * 在不修改原始代码的情况下增强功能。\n\n装饰器本质上是一种通过附加元数据或增强类行为来实现功能的方式。\n\n\n2. 如何启用装饰器#\n\n在 TypeScript 中，装饰器是一个实验性功能，所以默认情况下是禁用的。要启用装饰器，你需要在 tsconfig.json 文件中进行如下配置：\n\n\n\n\n3. 装饰器的类型#\n\n在 TypeScript 中，装饰器分为几种类型，分别用于不同的场景。以下是常见的装饰器类型：\n\n\n3.1 类装饰器（Class Decorators）#\n\n类装饰器用于修改类的行为，它是一个函数，接收构造函数作为参数。\n\n\n\n\n3.2 方法装饰器（Method Decorators）#\n\n方法装饰器用于修改类的方法，它接收三个参数：\n\n * target: 方法所在的类的原型。\n * key: 方法名。\n * descriptor: 方法的属性描述符。\n\n示例：\n\n\n\n\n3.3 属性装饰器（Property Decorators）#\n\n属性装饰器用于修改类的属性，接收两个参数：\n\n * target: 类的构造函数。\n * key: 属性名。\n\n示例：\n\n\n\n\n3.4 参数装饰器（Parameter Decorators）#\n\n参数装饰器用于修改类方法的参数，它接收三个参数：\n\n * target: 方法所在的类的原型。\n * key: 方法名。\n * index: 参数索引。\n\n示例：\n\n\n\n\n4. 装饰器工厂（Decorator Factories）#\n\n装饰器工厂是一个返回装饰器函数的函数，它允许你在装饰器中传递参数。这对于需要动态配置装饰器行为的场景非常有用。\n\n示例：\n\n\n\n\n5. 装饰器的应用场景#\n\n装饰器在多个领域有广泛的应用，以下是几个常见的场景：\n\n 1. 日志记录\n\n使用装饰器来记录方法调用、参数和返回值，对于调试和性能监控非常有帮助。\n\n 2. 权限控制\n\n可以通过装饰器在方法执行前验证权限，确保只有具有合适权限的用户才能执行特定操作。\n\n 3. AOP（面向切面编程）\n\n通过装饰器为方法、类添加额外的行为，类似于 AOP 中的切面，增强系统功能。\n\n\n6. 注意事项与最佳实践#\n\n * 装饰器是一个实验性特性，因此在生产环境中使用时需要小心。\n * 使用装饰器时要确保它们不会过度复杂化你的代码，装饰器的目的是增强而不是替代现有的功能。\n * 如果你需要修改类的方法或属性，优先考虑装饰器，但也要了解它可能引入的性能开销。\n\n\n7. 总结#\n\n装饰器是 TypeScript\n中非常强大的功能，它为开发者提供了在运行时修改类行为和属性的能力。通过装饰器，你可以实现代码的解耦、复用，并提升代码的可维护性和可扩展性。在实际开发中，装饰器常\n用于日志记录、权限控制、缓存和 AOP 等场景。\n\n如果你还没有尝试过装饰器，不妨在你的 TypeScript 项目中开启装饰器功能，体验这一强大特性带来的便利。","routePath":"/Explorers-Notes/frontEnd/typescript/decorator","lang":"","toc":[{"text":"1. 什么是装饰器？","id":"1-什么是装饰器","depth":2,"charIndex":97},{"text":"装饰器的作用","id":"装饰器的作用","depth":3,"charIndex":250},{"text":"2. 如何启用装饰器","id":"2-如何启用装饰器","depth":2,"charIndex":356},{"text":"3. 装饰器的类型","id":"3-装饰器的类型","depth":2,"charIndex":449},{"text":"3.1 类装饰器（Class Decorators）","id":"31-类装饰器class-decorators","depth":3,"charIndex":511},{"text":"3.2 方法装饰器（Method Decorators）","id":"32-方法装饰器method-decorators","depth":3,"charIndex":576},{"text":"3.3 属性装饰器（Property Decorators）","id":"33-属性装饰器property-decorators","depth":3,"charIndex":700},{"text":"3.4 参数装饰器（Parameter Decorators）","id":"34-参数装饰器parameter-decorators","depth":3,"charIndex":797},{"text":"4. 装饰器工厂（Decorator Factories）","id":"4-装饰器工厂decorator-factories","depth":2,"charIndex":917},{"text":"5. 装饰器的应用场景","id":"5-装饰器的应用场景","depth":2,"charIndex":1014},{"text":"6. 注意事项与最佳实践","id":"6-注意事项与最佳实践","depth":2,"charIndex":1213},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":1352}],"domain":"","frontmatter":{"title":"TypeScript 装饰器","date":"2024-12-27T17:00:00.000Z"},"version":""},{"id":12,"title":"前端性能优化","content":"#\n\n前端性能优化是提升 Web 应用用户体验的关键。优化页面加载速度、响应速度和交互性能不仅能提高用户满意度，还能改善 SEO\n排名。本文将介绍前端性能优化的一些常见技巧和实践。\n\n\n1. 减少 HTTP 请求#\n\n\n合并文件#\n\n每个文件（如 CSS、JavaScript 文件）都会发起一个 HTTP 请求。通过将多个 CSS 或 JavaScript\n文件合并成一个文件，可以减少请求次数，进而提高页面加载速度。\n\n实践：\n\n * 使用构建工具（如 Webpack）将多个文件合并。\n * 使用 CSS、JS 压缩工具（如 UglifyJS、Terser）减少文件体积。\n\n\n使用图像精灵#\n\n图像精灵（Image Sprites）将多个小图片合并成一张大图片，通过 CSS 的 background-position\n属性控制显示区域，从而减少图像请求次数。\n\n实践：\n\n * 使用工具（如 SpriteMe）将图像合并成精灵图。\n * 在 CSS 中使用 background-image 和 background-position 定位显示的图像部分。\n\n\n2. 资源压缩与合并#\n\n\n压缩 JavaScript 和 CSS#\n\nJavaScript 和 CSS 文件的压缩可以减少文件的体积，节省带宽，缩短加载时间。常见的压缩工具有 UglifyJS、Terser、CSSNano 等。\n\n实践：\n\n * 使用 Webpack、Rollup 等构建工具，自动压缩和合并代码。\n * 在生产环境中启用压缩功能，减小文件大小。\n\n\n使用 Gzip 或 Brotli 压缩#\n\nGzip 和 Brotli 是常见的文件压缩技术，通过在服务器上启用 Gzip 或 Brotli 压缩，可以显著减小文件大小，加速传输。\n\n实践：\n\n * 在服务器端启用 Gzip 或 Brotli 压缩。\n * 设置合适的 Content-Encoding 响应头。\n\n\n3. 图片优化#\n\n\n使用合适的图片格式#\n\n不同的图像格式对文件大小有很大影响。例如，WebP 格式的图像比 JPEG 或 PNG 格式的图像小得多。对于透明背景的图像，WebP 和 SVG\n可能是更好的选择。\n\n实践：\n\n * 将 JPEG 和 PNG 图片转换为 WebP 格式。\n * 使用工具（如 ImageOptim、TinyPNG）压缩图片。\n\n\n延迟加载（Lazy Load）#\n\n延迟加载（Lazy Loading）技术可以让页面只加载当前视口内的图像，当用户滚动页面时再加载其他图像，从而减少初始加载的资源。\n\n实践：\n\n * 使用 loading=\"lazy\" 属性来延迟加载图像。\n * 使用 JavaScript 库（如 Lozad.js）来实现懒加载。\n\n\n4. 代码异步加载#\n\n\n异步加载 JavaScript#\n\nJavaScript 文件可能会阻塞页面的渲染，导致页面加载缓慢。通过使用 async 或 defer 属性，可以异步加载 JavaScript\n文件，避免阻塞页面渲染。\n\n实践：\n\n * 在","routePath":"/Explorers-Notes/frontEnd/web/frontEnd","lang":"","toc":[{"text":"1. 减少 HTTP 请求","id":"1-减少-http-请求","depth":2,"charIndex":92},{"text":"合并文件","id":"合并文件","depth":3,"charIndex":109},{"text":"使用图像精灵","id":"使用图像精灵","depth":3,"charIndex":291},{"text":"2. 资源压缩与合并","id":"2-资源压缩与合并","depth":2,"charIndex":485},{"text":"压缩 JavaScript 和 CSS","id":"压缩-javascript-和-css","depth":3,"charIndex":499},{"text":"使用 Gzip 或 Brotli 压缩","id":"使用-gzip-或-brotli-压缩","depth":3,"charIndex":671},{"text":"3. 图片优化","id":"3-图片优化","depth":2,"charIndex":830},{"text":"使用合适的图片格式","id":"使用合适的图片格式","depth":3,"charIndex":841},{"text":"延迟加载（Lazy Load）","id":"延迟加载lazy-load","depth":3,"charIndex":1011},{"text":"4. 代码异步加载","id":"4-代码异步加载","depth":2,"charIndex":1173},{"text":"异步加载 JavaScript","id":"异步加载-javascript","depth":3,"charIndex":1186},{"text":"按需加载（Code Splitting）","id":"按需加载code-splitting","depth":3,"charIndex":-1},{"text":"5. 浏览器缓存","id":"5-浏览器缓存","depth":2,"charIndex":-1},{"text":"设置合理的缓存策略","id":"设置合理的缓存策略","depth":3,"charIndex":-1},{"text":"使用 Service Worker 缓存资源","id":"使用-service-worker-缓存资源","depth":3,"charIndex":-1},{"text":"6. 减少重绘和重排","id":"6-减少重绘和重排","depth":2,"charIndex":-1},{"text":"避免频繁操作 DOM","id":"避免频繁操作-dom","depth":3,"charIndex":-1},{"text":"使用 CSS 动画代替 JavaScript 动画","id":"使用-css-动画代替-javascript-动画","depth":3,"charIndex":-1},{"text":"7. 总结","id":"7-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"前端性能优化","date":"2024-12-27T15:00:00.000Z"},"version":""},{"id":13,"title":"模版","content":"#\n\n前端框架（如 React、Vue、Angular）提供了构建 Web\n应用的高效方式，但不当使用或未优化的框架可能会影响应用的性能。通过优化前端框架的使用，能够提升应用的加载速度、响应速度和用户体验。本文将介绍一些常见的前端框架优\n化技巧和最佳实践。\n\n\n1. React 性能优化#\n\n\n1.1 避免不必要的渲染#\n\nReact 会在组件状态或属性（props）变化时重新渲染组件。如果不加以控制，可能导致不必要的渲染，影响性能。可以通过 React.memo() 或\nshouldComponentUpdate() 来避免不必要的渲染。\n\n实践：\n\n * 使用 React.memo() 包裹函数组件，避免重复渲染相同的组件。\n * 使用 shouldComponentUpdate() 来判断是否需要重新渲染类组件。\n\n\n1.2 组件懒加载#\n\nReact 提供了 React.lazy() 和 Suspense 来实现组件懒加载，只有在需要时才加载组件，减少首次加载时的包大小。\n\n实践：\n\n * 使用 React.lazy() 和 Suspense 来按需加载组件。\n * 对于路由组件，使用 React Router 和 React.lazy() 实现懒加载。\n\n\n1.3 减少重渲染和更新#\n\n避免使用深层嵌套的状态和属性传递，避免组件嵌套层级过多，减少状态更新时的渲染开销。\n\n实践：\n\n * 使用 Context API 或 Redux 等集中管理状态，避免组件树深度过大。\n * 使用 useMemo() 和 useCallback() 缓存值和函数，避免重复计算和渲染。\n\n\n1.4 代码拆分与懒加载#\n\n使用 Webpack 的代码拆分功能，将应用拆分成多个小块，只加载当前页面需要的代码。\n\n实践：\n\n * 在 Webpack 配置中启用代码拆分（splitChunks）。\n * 使用动态导入（import()）语法来实现按需加载。\n\n\n2. Vue 性能优化#\n\n\n2.1 使用 v-show 替代 v-if#\n\nv-if 会动态地创建和销毁 DOM 元素，而 v-show 只是控制元素的显示与隐藏，切换频繁的场景使用 v-show 会更加高效。\n\n实践：\n\n * 在频繁切换的 UI 组件中使用 v-show，避免 v-if 的销毁和重建成本。\n\n\n2.2 组件懒加载#\n\nVue 也支持组件懒加载，可以按需加载组件，减少初始页面的 JavaScript 包大小。\n\n实践：\n\n * 使用 Vue.component() 和动态 import() 来实现按需加载组件。\n * 使用 Vue Router 的懒加载来实现路由组件的懒加载。\n\n\n2.3 优化计算属性#\n\n计算属性会缓存其计算结果，只有依赖的数据变化时才会重新计算。通过合理使用计算属性，避免不必要的重新计算。\n\n实践：\n\n * 使用计算属性而不是方法，避免每次重新计算。\n * 注意避免在计算属性中进行复杂的计算，导致性能瓶颈。\n\n\n2.4 使用 keep-alive 缓存组件#\n\n在切换多个组件时，可以使用 keep-alive 来缓存已经加载的组件，避免重复渲染。\n\n实践：\n\n * 使用 包裹组件，缓存未变化的组件。\n\n\n3. 通用优化技巧#\n\n\n3.1 按需加载（Code Splitting）#\n\n代码拆分是前端优化的一个重要策略，它可以将应用的 JavaScript 拆分成多个小文件，按需加载，避免加载不必要的代码。\n\n实践：\n\n * 使用 Webpack 的 splitChunks 配置实现代码拆分。\n * 对于路由进行懒加载，确保首次加载的 JS 资源最小。\n\n\n3.2 减少组件层级#\n\n避免过深的组件嵌套，因为过深的嵌套会增加 React 或 Vue 的渲染成本。可以通过简化组件结构或采用更高效的状态管理方式来优化。\n\n实践：\n\n * 使用状态管理工具（如 Redux、Vuex）来共享应用状态，减少嵌套的组件层级。\n * 将复杂的组件拆分成更小、更独立的组件。\n\n\n3.3 优化事件监听#\n\n避免不必要的事件监听，尤其是在频繁触发的事件（如滚动、窗口调整大小等）中。使用防抖（debounce）或节流（throttle）技术可以有效减少事件处理的次数。\n\n实践：\n\n * 使用防抖（debounce）或节流（throttle）技术来优化用户输入、滚动和窗口调整等事件。\n\n\n3.4 避免内联样式和内联函数#\n\n内联样式和内联函数每次组件渲染时都会被重新创建，增加不必要的开销。将样式和函数提取到外部，避免重复计算。\n\n实践：\n\n * 使用 CSS 样式表或 CSS-in-JS 方案来管理样式。\n * 将事件处理函数移到组件外部，避免每次渲染时创建新函数。\n\n\n4. 性能监控与分析#\n\n\n4.1 使用性能分析工具#\n\n使用 React 的 React DevTools 或 Vue 的 Vue DevTools 等开发者工具，可以帮助开发者分析组件的渲染和性能瓶颈，进行优化。\n\n实践：\n\n * 使用 React Profiler 或 Vue DevTools 监测组件的渲染时间。\n * 分析性能瓶颈并进行针对性优化。\n\n\n4.2 使用 Lighthouse 测试性能#\n\nLighthouse 是 Google 提供的一个开源工具，能够分析网页性能、SEO、可访问性等。使用 Lighthouse 进行性能评估，帮助发现优化点。\n\n实践：\n\n * 使用 Chrome 开发者工具中的 Lighthouse 进行性能分析。\n * 根据报告优化页面的加载速度和渲染效率。\n\n\n5. 总结#\n\n前端框架的优化可以通过多种方式提升应用性能。无论是通过 React 或 Vue\n的懒加载、组件缓存，还是使用代码拆分、避免不必要的渲染，合理的优化策略都能够显著提高 Web\n应用的性能。通过分析和监控应用的性能瓶颈，采取针对性的优化措施，可以带来更流畅的用户体验。\n\n持续关注和优化框架的使用，有助于提升开发效率和用户体验，确保 Web 应用在复杂的生产环境中仍能保持良好的性能。","routePath":"/Explorers-Notes/frontEnd/web/frontEndFrame","lang":"","toc":[{"text":"1. **React 性能优化**","id":"1-react-性能优化","depth":2,"charIndex":-1},{"text":"1.1 避免不必要的渲染","id":"11-避免不必要的渲染","depth":3,"charIndex":147},{"text":"1.2 组件懒加载","id":"12-组件懒加载","depth":3,"charIndex":366},{"text":"1.3 减少重渲染和更新","id":"13-减少重渲染和更新","depth":3,"charIndex":541},{"text":"1.4 代码拆分与懒加载","id":"14-代码拆分与懒加载","depth":3,"charIndex":701},{"text":"2. **Vue 性能优化**","id":"2-vue-性能优化","depth":2,"charIndex":-1},{"text":"2.1 使用 `v-show` 替代 `v-if`","id":"21-使用-v-show-替代-v-if","depth":3,"charIndex":-1},{"text":"2.2 组件懒加载","id":"22-组件懒加载","depth":3,"charIndex":994},{"text":"2.3 优化计算属性","id":"23-优化计算属性","depth":3,"charIndex":1140},{"text":"2.4 使用 `keep-alive` 缓存组件","id":"24-使用-keep-alive-缓存组件","depth":3,"charIndex":-1},{"text":"3. **通用优化技巧**","id":"3-通用优化技巧","depth":2,"charIndex":-1},{"text":"3.1 按需加载（Code Splitting）","id":"31-按需加载code-splitting","depth":3,"charIndex":1379},{"text":"3.2 减少组件层级","id":"32-减少组件层级","depth":3,"charIndex":1544},{"text":"3.3 优化事件监听","id":"33-优化事件监听","depth":3,"charIndex":1699},{"text":"3.4 避免内联样式和内联函数","id":"34-避免内联样式和内联函数","depth":3,"charIndex":1853},{"text":"4. **性能监控与分析**","id":"4-性能监控与分析","depth":2,"charIndex":-1},{"text":"4.1 使用性能分析工具","id":"41-使用性能分析工具","depth":3,"charIndex":2011},{"text":"4.2 使用 Lighthouse 测试性能","id":"42-使用-lighthouse-测试性能","depth":3,"charIndex":2180},{"text":"5. **总结**","id":"5-总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"模版","date":"2024-12-27T15:00:00.000Z"},"version":""},{"id":15,"title":"","content":"","routePath":"/Explorers-Notes/links/Links","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"网海指南针","content":"#\n\n\n工具#\n\n\nReact 生态#\n\n\nVue 生态#\n\n\nCSS 生态#\n\n\nNode 生态#\n\n\n跨平台框架#\n\n\n可视化#\n\n\n打包编译工具#","routePath":"/Explorers-Notes/links/","lang":"","toc":[{"text":"工具","id":"工具","depth":2,"charIndex":3},{"text":"React 生态","id":"react-生态","depth":2,"charIndex":9},{"text":"Vue 生态","id":"vue-生态","depth":2,"charIndex":21},{"text":"CSS 生态","id":"css-生态","depth":2,"charIndex":31},{"text":"Node 生态","id":"node-生态","depth":2,"charIndex":41},{"text":"跨平台框架","id":"跨平台框架","depth":2,"charIndex":52},{"text":"可视化","id":"可视化","depth":2,"charIndex":61},{"text":"打包编译工具","id":"打包编译工具","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"pageType":"doc","sidebar":false,"footer":false},"version":""},{"id":17,"title":"","content":"","routePath":"/Explorers-Notes/links/list/CSS","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"","content":"","routePath":"/Explorers-Notes/links/list/CrossPlatform","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Node","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"","content":"","routePath":"/Explorers-Notes/links/list/TOOL","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Visualization","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"","content":"","routePath":"/Explorers-Notes/links/list/Vue","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"","routePath":"/Explorers-Notes/links/list/buildTools","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"","content":"","routePath":"/Explorers-Notes/links/list/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"","content":"","routePath":"/Explorers-Notes/links/list/react","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]